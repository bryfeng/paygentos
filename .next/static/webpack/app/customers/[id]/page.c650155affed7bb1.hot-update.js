"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/[id]/page",{

/***/ "(app-pages-browser)/./src/api/customer/customer-api.ts":
/*!******************************************!*\
  !*** ./src/api/customer/customer-api.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerAPI: () => (/* binding */ CustomerAPI)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n// API client for customer endpoints\n\n// Table name in Supabase\nconst CUSTOMER_TABLE = 'customers';\n// Helper function to convert snake_case to camelCase (for API responses)\nfunction toCamelCase(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(toCamelCase);\n    }\n    return Object.keys(obj).reduce((result, key)=>{\n        // Convert snake_case to camelCase\n        const camelKey = key.replace(/(_[a-z])/g, (group)=>group.toUpperCase().replace('_', ''));\n        // Recursively convert nested objects/arrays\n        const value = typeof obj[key] === 'object' ? toCamelCase(obj[key]) : obj[key];\n        result[camelKey] = value;\n        return result;\n    }, {});\n}\nconst CustomerAPI = {\n    // Get all customers from the database\n    getCustomers: async ()=>{\n        try {\n            console.log('Fetching customers from database...');\n            // Use created_at (snake_case) for the database query\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').order('created_at', {\n                ascending: false\n            });\n            if (error) {\n                console.error('Error fetching customers from Supabase:', error.message);\n                throw new Error(\"Failed to fetch customers: \".concat(error.message));\n            }\n            // Return actual database results, even if empty array\n            console.log(\"Retrieved \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" customers from database\"));\n            // Convert snake_case properties to camelCase\n            return (data || []).map((customer)=>toCamelCase(customer));\n        } catch (error) {\n            console.error('Error in getCustomers:', error);\n            throw error; // Re-throw to let component handle the error\n        }\n    },\n    // Get customer by ID from database (fallback to mock data only if error)\n    getCustomer: async (id)=>{\n        try {\n            console.log(\"Fetching customer \".concat(id, \" from database...\"));\n            // Convert string ID to UUID format for database if needed\n            let queryId = id;\n            if (id.length === 1) {\n                // This handles the case of mock data IDs ('1', '2', '3')\n                // being used before migration to database\n                queryId = \"00000000-0000-0000-0000-00000000000\".concat(id);\n                console.log(\"Converting simple ID \".concat(id, \" to UUID format: \").concat(queryId));\n            }\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', queryId).single();\n            if (error) {\n                console.warn(\"Error fetching customer \".concat(id, \":\"), error.message);\n                // Only try to find in mock data if database query failed\n                const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n                if (mockCustomer) {\n                    console.log(\"Found customer \".concat(id, \" in mock data\"));\n                    return mockCustomer;\n                }\n                return null;\n            }\n            console.log(\"Successfully retrieved customer \".concat(id, \" from database\"));\n            return data;\n        } catch (error) {\n            console.error(\"Error in getCustomer \".concat(id, \":\"), error);\n            // Last resort fallback to mock data\n            const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n            return mockCustomer || null;\n        }\n    },\n    // Create new customer\n    createCustomer: async (customer)=>{\n        try {\n            var _customer_contacts, _customer_idDocuments;\n            // Find primary contact for logging\n            const primaryContact = (_customer_contacts = customer.contacts) === null || _customer_contacts === void 0 ? void 0 : _customer_contacts.find((c)=>c.isPrimary);\n            const contactInfo = primaryContact ? \"\".concat(primaryContact.type, \": \").concat(primaryContact.value) : 'No primary contact';\n            console.log('Creating new customer via API route:', {\n                name: customer.fullName || \"\".concat(customer.firstName, \" \").concat(customer.lastName),\n                contact: contactInfo,\n                document_count: ((_customer_idDocuments = customer.idDocuments) === null || _customer_idDocuments === void 0 ? void 0 : _customer_idDocuments.length) || 0\n            });\n            // Call our Next.js API route instead of Supabase directly\n            // This avoids CORS issues since the API route runs server-side\n            const response = await fetch('/api/customers', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(customer)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Error response from API:', errorData);\n                throw new Error(errorData.error || 'Failed to create customer');\n            }\n            const data = await response.json();\n            console.log('Successfully created customer with ID:', data.id);\n            return data;\n        } catch (error) {\n            console.error('Error in createCustomer:', error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Update customer\n    updateCustomer: async (id, customer)=>{\n        try {\n            // First get the existing customer to ensure we don't lose data\n            const { data: existingCustomer, error: fetchError } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', id).single();\n            if (fetchError) {\n                console.error(\"Error fetching existing customer \".concat(id, \":\"), fetchError.message);\n                throw fetchError;\n            }\n            // Generate full name if first or last name is being updated\n            let fullName = customer.fullName;\n            var _customer_firstName;\n            const firstName = (_customer_firstName = customer.firstName) !== null && _customer_firstName !== void 0 ? _customer_firstName : existingCustomer.firstName;\n            var _customer_lastName;\n            const lastName = (_customer_lastName = customer.lastName) !== null && _customer_lastName !== void 0 ? _customer_lastName : existingCustomer.lastName;\n            if (!fullName && firstName && lastName) {\n                fullName = \"\".concat(firstName, \" \").concat(lastName);\n            }\n            // Handle contacts array merging if provided\n            let contacts = existingCustomer.contacts || [];\n            if (customer.contacts) {\n                contacts = customer.contacts;\n                // Ensure at least one contact is primary if there are contacts\n                if (contacts.length > 0 && !contacts.some((c)=>c.isPrimary)) {\n                    contacts[0].isPrimary = true;\n                }\n            }\n            var _customer_idDocuments;\n            // Handle ID documents array merging if provided\n            const idDocuments = (_customer_idDocuments = customer.idDocuments) !== null && _customer_idDocuments !== void 0 ? _customer_idDocuments : existingCustomer.idDocuments || [];\n            // Prepare the updated customer object\n            const updatedCustomer = {\n                ...existingCustomer,\n                ...customer,\n                fullName: fullName || existingCustomer.fullName,\n                contacts,\n                idDocuments,\n                updatedAt: new Date().toISOString()\n            };\n            // Find primary contact for logging\n            const primaryContact = contacts.find((c)=>c.isPrimary);\n            const contactInfo = primaryContact ? \"\".concat(primaryContact.type, \": \").concat(primaryContact.value) : 'No primary contact';\n            console.log(\"Updating customer \".concat(id, \":\"), {\n                name: updatedCustomer.fullName,\n                contact: contactInfo,\n                document_count: idDocuments.length\n            });\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).update(updatedCustomer).eq('id', id).select().single();\n            if (error) {\n                console.error(\"Error updating customer \".concat(id, \":\"), error.message);\n                throw error;\n            }\n            console.log(\"Successfully updated customer \".concat(id));\n            return data;\n        } catch (error) {\n            console.error(\"Error in updateCustomer \".concat(id, \":\"), error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Delete customer\n    deleteCustomer: async (id)=>{\n        try {\n            const { error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).delete().eq('id', id);\n            if (error) {\n                console.error(\"Error deleting customer \".concat(id, \":\"), error.message);\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in deleteCustomer \".concat(id, \":\"), error);\n            return false;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0NBQW9DO0FBUXVCO0FBRTNELHlCQUF5QjtBQUN6QixNQUFNQyxpQkFBaUI7QUFFdkIseUVBQXlFO0FBQ3pFLFNBQVNDLFlBQVlDLEdBQVE7SUFDM0IsSUFBSUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtRQUMzQyxPQUFPQTtJQUNUO0lBRUEsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixNQUFNO1FBQ3RCLE9BQU9BLElBQUlHLEdBQUcsQ0FBQ0o7SUFDakI7SUFFQSxPQUFPSyxPQUFPQyxJQUFJLENBQUNMLEtBQUtNLE1BQU0sQ0FBQyxDQUFDQyxRQUFRQztRQUN0QyxrQ0FBa0M7UUFDbEMsTUFBTUMsV0FBV0QsSUFBSUUsT0FBTyxDQUFDLGFBQWEsQ0FBQ0MsUUFBVUEsTUFBTUMsV0FBVyxHQUFHRixPQUFPLENBQUMsS0FBSztRQUV0Riw0Q0FBNEM7UUFDNUMsTUFBTUcsUUFBUSxPQUFPYixHQUFHLENBQUNRLElBQUksS0FBSyxXQUFXVCxZQUFZQyxHQUFHLENBQUNRLElBQUksSUFBSVIsR0FBRyxDQUFDUSxJQUFJO1FBRTdFRCxNQUFNLENBQUNFLFNBQVMsR0FBR0k7UUFDbkIsT0FBT047SUFDVCxHQUFHLENBQUM7QUFDTjtBQUVPLE1BQU1PLGNBQWM7SUFDekIsc0NBQXNDO0lBQ3RDQyxjQUFjO1FBQ1osSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixxREFBcUQ7WUFDckQsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU10QixxREFBUUEsQ0FDbkN1QixJQUFJLENBQUN0QixnQkFDTHVCLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsY0FBYztnQkFBRUMsV0FBVztZQUFNO1lBRTFDLElBQUlKLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQ0FBMkNBLE1BQU1LLE9BQU87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QUFDdEIsZ0JBQ0x1RSxNQUFNLENBQUNKLGlCQUNQbEMsRUFBRSxDQUFDLE1BQU1GLElBQ1RSLE1BQU0sR0FDTlcsTUFBTTtZQUVULElBQUliLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSFUsSUFBRyxNQUFJVixNQUFNSyxPQUFPO2dCQUM3RCxNQUFNTDtZQUNSO1lBRUFILFFBQVFDLEdBQUcsQ0FBQyxpQ0FBb0MsT0FBSFk7WUFDN0MsT0FBT1g7UUFDVCxFQUFFLE9BQU9DLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIVSxJQUFHLE1BQUlWO1lBQ2hELE1BQU1BLE9BQU8sZ0RBQWdEO1FBQy9EO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEJtRCxnQkFBZ0IsT0FBT3pDO1FBQ3JCLElBQUk7WUFDRixNQUFNLEVBQUVWLEtBQUssRUFBRSxHQUFHLE1BQU10QixxREFBUUEsQ0FDN0J1QixJQUFJLENBQUN0QixnQkFDTHlFLE1BQU0sR0FDTnhDLEVBQUUsQ0FBQyxNQUFNRjtZQUVaLElBQUlWLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSFUsSUFBRyxNQUFJVixNQUFNSyxPQUFPO2dCQUM3RCxPQUFPO1lBQ1Q7WUFFQSxPQUFPO1FBQ1QsRUFBRSxPQUFPTCxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSFUsSUFBRyxNQUFJVjtZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbmZlbmcvcGF5bWVudC1hZ2VudC1wbGF0Zm9ybS9zcmMvYXBpL2N1c3RvbWVyL2N1c3RvbWVyLWFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgY2xpZW50IGZvciBjdXN0b21lciBlbmRwb2ludHNcbmltcG9ydCB7IFxuICBDdXN0b21lciwgXG4gIENvbnRhY3RUeXBlLCBcbiAgSWREb2N1bWVudFR5cGUsIFxuICBDb250YWN0SW5mbywgXG4gIElkRG9jdW1lbnQgXG59IGZyb20gJy4uLy4uL21vZGVscy9jdXN0b21lci9jdXN0b21lcic7XG5pbXBvcnQgeyBzdXBhYmFzZSwgc2FmZVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdXRpbHMvc3VwYWJhc2UnO1xuXG4vLyBUYWJsZSBuYW1lIGluIFN1cGFiYXNlXG5jb25zdCBDVVNUT01FUl9UQUJMRSA9ICdjdXN0b21lcnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBzbmFrZV9jYXNlIHRvIGNhbWVsQ2FzZSAoZm9yIEFQSSByZXNwb25zZXMpXG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShvYmo6IGFueSk6IGFueSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIFxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAodG9DYW1lbENhc2UpO1xuICB9XG4gIFxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgLy8gQ29udmVydCBzbmFrZV9jYXNlIHRvIGNhbWVsQ2FzZVxuICAgIGNvbnN0IGNhbWVsS2V5ID0ga2V5LnJlcGxhY2UoLyhfW2Etel0pL2csIChncm91cCkgPT4gZ3JvdXAudG9VcHBlckNhc2UoKS5yZXBsYWNlKCdfJywgJycpKTtcbiAgICBcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IG5lc3RlZCBvYmplY3RzL2FycmF5c1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JyA/IHRvQ2FtZWxDYXNlKG9ialtrZXldKSA6IG9ialtrZXldO1xuICAgIFxuICAgIHJlc3VsdFtjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSBhcyBhbnkpO1xufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tZXJBUEkgPSB7XG4gIC8vIEdldCBhbGwgY3VzdG9tZXJzIGZyb20gdGhlIGRhdGFiYXNlXG4gIGdldEN1c3RvbWVyczogYXN5bmMgKCk6IFByb21pc2U8Q3VzdG9tZXJbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgY3VzdG9tZXJzIGZyb20gZGF0YWJhc2UuLi4nKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIGNyZWF0ZWRfYXQgKHNuYWtlX2Nhc2UpIGZvciB0aGUgZGF0YWJhc2UgcXVlcnlcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY3VzdG9tZXJzIGZyb20gU3VwYWJhc2U6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGN1c3RvbWVyczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYWN0dWFsIGRhdGFiYXNlIHJlc3VsdHMsIGV2ZW4gaWYgZW1wdHkgYXJyYXlcbiAgICAgIGNvbnNvbGUubG9nKGBSZXRyaWV2ZWQgJHtkYXRhPy5sZW5ndGggfHwgMH0gY3VzdG9tZXJzIGZyb20gZGF0YWJhc2VgKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBzbmFrZV9jYXNlIHByb3BlcnRpZXMgdG8gY2FtZWxDYXNlXG4gICAgICByZXR1cm4gKGRhdGEgfHwgW10pLm1hcChjdXN0b21lciA9PiB0b0NhbWVsQ2FzZShjdXN0b21lcikpIGFzIEN1c3RvbWVyW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldEN1c3RvbWVyczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdG8gbGV0IGNvbXBvbmVudCBoYW5kbGUgdGhlIGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBjdXN0b21lciBieSBJRCBmcm9tIGRhdGFiYXNlIChmYWxsYmFjayB0byBtb2NrIGRhdGEgb25seSBpZiBlcnJvcilcbiAgZ2V0Q3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxDdXN0b21lciB8IG51bGw+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGN1c3RvbWVyICR7aWR9IGZyb20gZGF0YWJhc2UuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBzdHJpbmcgSUQgdG8gVVVJRCBmb3JtYXQgZm9yIGRhdGFiYXNlIGlmIG5lZWRlZFxuICAgICAgbGV0IHF1ZXJ5SWQgPSBpZDtcbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIG1vY2sgZGF0YSBJRHMgKCcxJywgJzInLCAnMycpXG4gICAgICAgIC8vIGJlaW5nIHVzZWQgYmVmb3JlIG1pZ3JhdGlvbiB0byBkYXRhYmFzZVxuICAgICAgICBxdWVyeUlkID0gYDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwJHtpZH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyBzaW1wbGUgSUQgJHtpZH0gdG8gVVVJRCBmb3JtYXQ6ICR7cXVlcnlJZH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oQ1VTVE9NRVJfVEFCTEUpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcXVlcnlJZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBmZXRjaGluZyBjdXN0b21lciAke2lkfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgLy8gT25seSB0cnkgdG8gZmluZCBpbiBtb2NrIGRhdGEgaWYgZGF0YWJhc2UgcXVlcnkgZmFpbGVkXG4gICAgICAgIGNvbnN0IG1vY2tDdXN0b21lciA9IE1PQ0tfQ1VTVE9NRVJTLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChtb2NrQ3VzdG9tZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgY3VzdG9tZXIgJHtpZH0gaW4gbW9jayBkYXRhYCk7XG4gICAgICAgICAgcmV0dXJuIG1vY2tDdXN0b21lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgY3VzdG9tZXIgJHtpZH0gZnJvbSBkYXRhYmFzZWApO1xuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldEN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIC8vIExhc3QgcmVzb3J0IGZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgY29uc3QgbW9ja0N1c3RvbWVyID0gTU9DS19DVVNUT01FUlMuZmluZChjID0+IGMuaWQgPT09IGlkKTtcbiAgICAgIHJldHVybiBtb2NrQ3VzdG9tZXIgfHwgbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBjcmVhdGVDdXN0b21lcjogYXN5bmMgKGN1c3RvbWVyOiBQYXJ0aWFsPEN1c3RvbWVyPik6IFByb21pc2U8Q3VzdG9tZXIgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmQgcHJpbWFyeSBjb250YWN0IGZvciBsb2dnaW5nXG4gICAgICBjb25zdCBwcmltYXJ5Q29udGFjdCA9IGN1c3RvbWVyLmNvbnRhY3RzPy5maW5kKGMgPT4gYy5pc1ByaW1hcnkpO1xuICAgICAgY29uc3QgY29udGFjdEluZm8gPSBwcmltYXJ5Q29udGFjdCA/IGAke3ByaW1hcnlDb250YWN0LnR5cGV9OiAke3ByaW1hcnlDb250YWN0LnZhbHVlfWAgOiAnTm8gcHJpbWFyeSBjb250YWN0JztcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG5ldyBjdXN0b21lciB2aWEgQVBJIHJvdXRlOicsIHsgXG4gICAgICAgIG5hbWU6IGN1c3RvbWVyLmZ1bGxOYW1lIHx8IGAke2N1c3RvbWVyLmZpcnN0TmFtZX0gJHtjdXN0b21lci5sYXN0TmFtZX1gLFxuICAgICAgICBjb250YWN0OiBjb250YWN0SW5mbyxcbiAgICAgICAgZG9jdW1lbnRfY291bnQ6IGN1c3RvbWVyLmlkRG9jdW1lbnRzPy5sZW5ndGggfHwgMFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENhbGwgb3VyIE5leHQuanMgQVBJIHJvdXRlIGluc3RlYWQgb2YgU3VwYWJhc2UgZGlyZWN0bHlcbiAgICAgIC8vIFRoaXMgYXZvaWRzIENPUlMgaXNzdWVzIHNpbmNlIHRoZSBBUEkgcm91dGUgcnVucyBzZXJ2ZXItc2lkZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jdXN0b21lcnMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY3VzdG9tZXIpLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBmcm9tIEFQSTonLCBlcnJvckRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gY3JlYXRlIGN1c3RvbWVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgY3VzdG9tZXIgd2l0aCBJRDonLCBkYXRhLmlkKTtcbiAgICAgIHJldHVybiBkYXRhIGFzIEN1c3RvbWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZUN1c3RvbWVyOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0byBhbGxvdyBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaW4gVUlcbiAgICB9XG4gIH0sXG5cbiAgLy8gVXBkYXRlIGN1c3RvbWVyXG4gIHVwZGF0ZUN1c3RvbWVyOiBhc3luYyAoaWQ6IHN0cmluZywgY3VzdG9tZXI6IFBhcnRpYWw8Q3VzdG9tZXI+KTogUHJvbWlzZTxDdXN0b21lciB8IG51bGw+ID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgZ2V0IHRoZSBleGlzdGluZyBjdXN0b21lciB0byBlbnN1cmUgd2UgZG9uJ3QgbG9zZSBkYXRhXG4gICAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nQ3VzdG9tZXIsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZmV0Y2hFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBleGlzdGluZyBjdXN0b21lciAke2lkfTpgLCBmZXRjaEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBmdWxsIG5hbWUgaWYgZmlyc3Qgb3IgbGFzdCBuYW1lIGlzIGJlaW5nIHVwZGF0ZWRcbiAgICAgIGxldCBmdWxsTmFtZSA9IGN1c3RvbWVyLmZ1bGxOYW1lO1xuICAgICAgY29uc3QgZmlyc3ROYW1lID0gY3VzdG9tZXIuZmlyc3ROYW1lID8/IGV4aXN0aW5nQ3VzdG9tZXIuZmlyc3ROYW1lO1xuICAgICAgY29uc3QgbGFzdE5hbWUgPSBjdXN0b21lci5sYXN0TmFtZSA/PyBleGlzdGluZ0N1c3RvbWVyLmxhc3ROYW1lO1xuICAgICAgXG4gICAgICBpZiAoIWZ1bGxOYW1lICYmIGZpcnN0TmFtZSAmJiBsYXN0TmFtZSkge1xuICAgICAgICBmdWxsTmFtZSA9IGAke2ZpcnN0TmFtZX0gJHtsYXN0TmFtZX1gO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgY29udGFjdHMgYXJyYXkgbWVyZ2luZyBpZiBwcm92aWRlZFxuICAgICAgbGV0IGNvbnRhY3RzID0gZXhpc3RpbmdDdXN0b21lci5jb250YWN0cyB8fCBbXTtcbiAgICAgIGlmIChjdXN0b21lci5jb250YWN0cykge1xuICAgICAgICBjb250YWN0cyA9IGN1c3RvbWVyLmNvbnRhY3RzO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIGF0IGxlYXN0IG9uZSBjb250YWN0IGlzIHByaW1hcnkgaWYgdGhlcmUgYXJlIGNvbnRhY3RzXG4gICAgICAgIGlmIChjb250YWN0cy5sZW5ndGggPiAwICYmICFjb250YWN0cy5zb21lKGMgPT4gYy5pc1ByaW1hcnkpKSB7XG4gICAgICAgICAgY29udGFjdHNbMF0uaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgSUQgZG9jdW1lbnRzIGFycmF5IG1lcmdpbmcgaWYgcHJvdmlkZWRcbiAgICAgIGNvbnN0IGlkRG9jdW1lbnRzID0gY3VzdG9tZXIuaWREb2N1bWVudHMgPz8gKGV4aXN0aW5nQ3VzdG9tZXIuaWREb2N1bWVudHMgfHwgW10pO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSB1cGRhdGVkIGN1c3RvbWVyIG9iamVjdFxuICAgICAgY29uc3QgdXBkYXRlZEN1c3RvbWVyID0ge1xuICAgICAgICAuLi5leGlzdGluZ0N1c3RvbWVyLFxuICAgICAgICAuLi5jdXN0b21lcixcbiAgICAgICAgZnVsbE5hbWU6IGZ1bGxOYW1lIHx8IGV4aXN0aW5nQ3VzdG9tZXIuZnVsbE5hbWUsXG4gICAgICAgIGNvbnRhY3RzLFxuICAgICAgICBpZERvY3VtZW50cyxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpbmQgcHJpbWFyeSBjb250YWN0IGZvciBsb2dnaW5nXG4gICAgICBjb25zdCBwcmltYXJ5Q29udGFjdCA9IGNvbnRhY3RzLmZpbmQoYyA9PiBjLmlzUHJpbWFyeSk7XG4gICAgICBjb25zdCBjb250YWN0SW5mbyA9IHByaW1hcnlDb250YWN0IFxuICAgICAgICA/IGAke3ByaW1hcnlDb250YWN0LnR5cGV9OiAke3ByaW1hcnlDb250YWN0LnZhbHVlfWAgXG4gICAgICAgIDogJ05vIHByaW1hcnkgY29udGFjdCc7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBjdXN0b21lciAke2lkfTpgLCB7XG4gICAgICAgIG5hbWU6IHVwZGF0ZWRDdXN0b21lci5mdWxsTmFtZSxcbiAgICAgICAgY29udGFjdDogY29udGFjdEluZm8sXG4gICAgICAgIGRvY3VtZW50X2NvdW50OiBpZERvY3VtZW50cy5sZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVkQ3VzdG9tZXIpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGN1c3RvbWVyICR7aWR9YCk7XG4gICAgICByZXR1cm4gZGF0YSBhcyBDdXN0b21lcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gdXBkYXRlQ3VzdG9tZXIgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGFsbG93IHByb3BlciBlcnJvciBoYW5kbGluZyBpbiBVSVxuICAgIH1cbiAgfSxcblxuICAvLyBEZWxldGUgY3VzdG9tZXJcbiAgZGVsZXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBkZWxldGVDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiQ1VTVE9NRVJfVEFCTEUiLCJ0b0NhbWVsQ2FzZSIsIm9iaiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJrZXkiLCJjYW1lbEtleSIsInJlcGxhY2UiLCJncm91cCIsInRvVXBwZXJDYXNlIiwidmFsdWUiLCJDdXN0b21lckFQSSIsImdldEN1c3RvbWVycyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJtZXNzYWdlIiwiRXJyb3IiLCJsZW5ndGgiLCJjdXN0b21lciIsImdldEN1c3RvbWVyIiwiaWQiLCJxdWVyeUlkIiwiZXEiLCJzaW5nbGUiLCJ3YXJuIiwibW9ja0N1c3RvbWVyIiwiTU9DS19DVVNUT01FUlMiLCJmaW5kIiwiYyIsImNyZWF0ZUN1c3RvbWVyIiwicHJpbWFyeUNvbnRhY3QiLCJjb250YWN0cyIsImlzUHJpbWFyeSIsImNvbnRhY3RJbmZvIiwidHlwZSIsIm5hbWUiLCJmdWxsTmFtZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiY29udGFjdCIsImRvY3VtZW50X2NvdW50IiwiaWREb2N1bWVudHMiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwidXBkYXRlQ3VzdG9tZXIiLCJleGlzdGluZ0N1c3RvbWVyIiwiZmV0Y2hFcnJvciIsInNvbWUiLCJ1cGRhdGVkQ3VzdG9tZXIiLCJ1cGRhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGUiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/api/customer/customer-api.ts\n"));

/***/ })

});