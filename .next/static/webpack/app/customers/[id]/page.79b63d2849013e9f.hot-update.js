"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/[id]/page",{

/***/ "(app-pages-browser)/./src/api/customer/customer-api.ts":
/*!******************************************!*\
  !*** ./src/api/customer/customer-api.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerAPI: () => (/* binding */ CustomerAPI)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n// API client for customer endpoints\n\n// Table name in Supabase\nconst CUSTOMER_TABLE = 'customers';\n// Mock data for development/fallback\nconst MOCK_CUSTOMERS = [\n    {\n        id: '1',\n        name: 'Acme Corporation',\n        email: 'contact@acme.com',\n        phone: '555-123-4567',\n        address: '123 Business Ave, Suite 100, New York, NY 10001',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '2',\n        name: 'Globex Industries',\n        email: 'info@globex.com',\n        phone: '555-987-6543',\n        address: '456 Corporate Blvd, Chicago, IL 60601',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '3',\n        name: 'Initech LLC',\n        email: 'support@initech.com',\n        phone: '555-456-7890',\n        address: '789 Tech Park, San Francisco, CA 94105',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    }\n];\nconst CustomerAPI = {\n    // Get all customers with fallback to mock data only if database fails\n    getCustomers: async ()=>{\n        try {\n            console.log('Fetching customers from database...');\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').order('createdAt', {\n                ascending: false\n            });\n            if (error) {\n                console.warn('Error fetching customers from Supabase:', error.message);\n                console.info('Using mock customer data as fallback');\n                return MOCK_CUSTOMERS;\n            }\n            if (data && data.length > 0) {\n                console.log(\"Successfully retrieved \".concat(data.length, \" customers from database\"));\n                return data;\n            } else {\n                console.log('No customers found in database, using mock data');\n                return MOCK_CUSTOMERS;\n            }\n        } catch (error) {\n            console.error('Error in getCustomers:', error);\n            return MOCK_CUSTOMERS; // Fallback to mock data in case of error\n        }\n    },\n    // Get customer by ID from database (fallback to mock data only if error)\n    getCustomer: async (id)=>{\n        try {\n            console.log(\"Fetching customer \".concat(id, \" from database...\"));\n            // Convert string ID to UUID format for database if needed\n            let queryId = id;\n            if (id.length === 1) {\n                // This handles the case of mock data IDs ('1', '2', '3')\n                // being used before migration to database\n                queryId = \"00000000-0000-0000-0000-00000000000\".concat(id);\n                console.log(\"Converting simple ID \".concat(id, \" to UUID format: \").concat(queryId));\n            }\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', queryId).single();\n            if (error) {\n                console.warn(\"Error fetching customer \".concat(id, \":\"), error.message);\n                // Only try to find in mock data if database query failed\n                const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n                if (mockCustomer) {\n                    console.log(\"Found customer \".concat(id, \" in mock data\"));\n                    return mockCustomer;\n                }\n                return null;\n            }\n            console.log(\"Successfully retrieved customer \".concat(id, \" from database\"));\n            return data;\n        } catch (error) {\n            console.error(\"Error in getCustomer \".concat(id, \":\"), error);\n            // Last resort fallback to mock data\n            const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n            return mockCustomer || null;\n        }\n    },\n    // Create new customer\n    createCustomer: async (customer)=>{\n        try {\n            // Add timestamps\n            const now = new Date().toISOString();\n            const newCustomer = {\n                ...customer,\n                createdAt: now,\n                updatedAt: now\n            };\n            console.log('Creating new customer in database:', {\n                ...newCustomer,\n                email: customer.email\n            });\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).insert([\n                newCustomer\n            ]).select().single();\n            if (error) {\n                console.error('Error creating customer:', error.message);\n                if (error.code === '23505') {\n                    throw new Error('A customer with this email already exists');\n                }\n                throw error;\n            }\n            console.log('Successfully created customer with ID:', data.id);\n            return data;\n        } catch (error) {\n            console.error('Error in createCustomer:', error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Update customer\n    updateCustomer: async (id, customer)=>{\n        try {\n            // Add updated timestamp\n            const updatedCustomer = {\n                ...customer,\n                updatedAt: new Date().toISOString()\n            };\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).update(updatedCustomer).eq('id', id).select().single();\n            if (error) {\n                console.error(\"Error updating customer \".concat(id, \":\"), error.message);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Error in updateCustomer \".concat(id, \":\"), error);\n            return null;\n        }\n    },\n    // Delete customer\n    deleteCustomer: async (id)=>{\n        try {\n            const { error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).delete().eq('id', id);\n            if (error) {\n                console.error(\"Error deleting customer \".concat(id, \":\"), error.message);\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in deleteCustomer \".concat(id, \":\"), error);\n            return false;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0NBQW9DO0FBRXVCO0FBRTNELHlCQUF5QjtBQUN6QixNQUFNQyxpQkFBaUI7QUFFdkIscUNBQXFDO0FBQ3JDLE1BQU1DLGlCQUE2QjtJQUNqQztRQUNFQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7UUFDakNFLFVBQVU7SUFDWjtJQUNBO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7UUFDakNDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztRQUNqQ0UsVUFBVTtJQUNaO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztRQUNqQ0MsV0FBVyxJQUFJRixPQUFPQyxXQUFXO1FBQ2pDRSxVQUFVO0lBQ1o7Q0FDRDtBQUVNLE1BQU1DLGNBQWM7SUFDekIsc0VBQXNFO0lBQ3RFQyxjQUFjO1FBQ1osSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWxCLHFEQUFRQSxDQUNuQ21CLElBQUksQ0FBQ2xCLGdCQUNMbUIsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQyxhQUFhO2dCQUFFQyxXQUFXO1lBQU07WUFFekMsSUFBSUosT0FBTztnQkFDVEgsUUFBUVEsSUFBSSxDQUFDLDJDQUEyQ0wsTUFBTU0sT0FBTztnQkFDckVULFFBQVFVLElBQUksQ0FBQztnQkFDYixPQUFPdkI7WUFDVDtZQUVBLElBQUll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QyxJQUFZZ0M7UUFDakMsSUFBSTtZQUNGLHdCQUF3QjtZQUN4QixNQUFNTyxrQkFBa0I7Z0JBQ3RCLEdBQUdQLFFBQVE7Z0JBQ1h4QixXQUFXLElBQUlGLE9BQU9DLFdBQVc7WUFDbkM7WUFFQSxNQUFNLEVBQUVPLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWxCLHFEQUFRQSxDQUNuQ21CLElBQUksQ0FBQ2xCLGdCQUNMMEMsTUFBTSxDQUFDRCxpQkFDUGIsRUFBRSxDQUFDLE1BQU0xQixJQUNUaUIsTUFBTSxHQUNOVSxNQUFNO1lBRVQsSUFBSVosT0FBTztnQkFDVEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIZixJQUFHLE1BQUllLE1BQU1NLE9BQU87Z0JBQzdELE1BQU1OO1lBQ1I7WUFFQSxPQUFPRDtRQUNULEVBQUUsT0FBT0MsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhmLElBQUcsTUFBSWU7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIwQixnQkFBZ0IsT0FBT3pDO1FBQ3JCLElBQUk7WUFDRixNQUFNLEVBQUVlLEtBQUssRUFBRSxHQUFHLE1BQU1sQixxREFBUUEsQ0FDN0JtQixJQUFJLENBQUNsQixnQkFDTDRDLE1BQU0sR0FDTmhCLEVBQUUsQ0FBQyxNQUFNMUI7WUFFWixJQUFJZSxPQUFPO2dCQUNUSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhmLElBQUcsTUFBSWUsTUFBTU0sT0FBTztnQkFDN0QsT0FBTztZQUNUO1lBRUEsT0FBTztRQUNULEVBQUUsT0FBT04sT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhmLElBQUcsTUFBSWU7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW5mZW5nL3BheW1lbnQtYWdlbnQtcGxhdGZvcm0vc3JjL2FwaS9jdXN0b21lci9jdXN0b21lci1hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIGNsaWVudCBmb3IgY3VzdG9tZXIgZW5kcG9pbnRzXG5pbXBvcnQgeyBDdXN0b21lciB9IGZyb20gJy4uLy4uL21vZGVscy9jdXN0b21lci9jdXN0b21lcic7XG5pbXBvcnQgeyBzdXBhYmFzZSwgc2FmZVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdXRpbHMvc3VwYWJhc2UnO1xuXG4vLyBUYWJsZSBuYW1lIGluIFN1cGFiYXNlXG5jb25zdCBDVVNUT01FUl9UQUJMRSA9ICdjdXN0b21lcnMnO1xuXG4vLyBNb2NrIGRhdGEgZm9yIGRldmVsb3BtZW50L2ZhbGxiYWNrXG5jb25zdCBNT0NLX0NVU1RPTUVSUzogQ3VzdG9tZXJbXSA9IFtcbiAge1xuICAgIGlkOiAnMScsXG4gICAgbmFtZTogJ0FjbWUgQ29ycG9yYXRpb24nLFxuICAgIGVtYWlsOiAnY29udGFjdEBhY21lLmNvbScsXG4gICAgcGhvbmU6ICc1NTUtMTIzLTQ1NjcnLFxuICAgIGFkZHJlc3M6ICcxMjMgQnVzaW5lc3MgQXZlLCBTdWl0ZSAxMDAsIE5ldyBZb3JrLCBOWSAxMDAwMScsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgaXNBY3RpdmU6IHRydWVcbiAgfSxcbiAge1xuICAgIGlkOiAnMicsXG4gICAgbmFtZTogJ0dsb2JleCBJbmR1c3RyaWVzJyxcbiAgICBlbWFpbDogJ2luZm9AZ2xvYmV4LmNvbScsXG4gICAgcGhvbmU6ICc1NTUtOTg3LTY1NDMnLFxuICAgIGFkZHJlc3M6ICc0NTYgQ29ycG9yYXRlIEJsdmQsIENoaWNhZ28sIElMIDYwNjAxJyxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBpc0FjdGl2ZTogdHJ1ZVxuICB9LFxuICB7XG4gICAgaWQ6ICczJyxcbiAgICBuYW1lOiAnSW5pdGVjaCBMTEMnLFxuICAgIGVtYWlsOiAnc3VwcG9ydEBpbml0ZWNoLmNvbScsXG4gICAgcGhvbmU6ICc1NTUtNDU2LTc4OTAnLFxuICAgIGFkZHJlc3M6ICc3ODkgVGVjaCBQYXJrLCBTYW4gRnJhbmNpc2NvLCBDQSA5NDEwNScsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgaXNBY3RpdmU6IHRydWVcbiAgfVxuXTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbWVyQVBJID0ge1xuICAvLyBHZXQgYWxsIGN1c3RvbWVycyB3aXRoIGZhbGxiYWNrIHRvIG1vY2sgZGF0YSBvbmx5IGlmIGRhdGFiYXNlIGZhaWxzXG4gIGdldEN1c3RvbWVyczogYXN5bmMgKCk6IFByb21pc2U8Q3VzdG9tZXJbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgY3VzdG9tZXJzIGZyb20gZGF0YWJhc2UuLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oQ1VTVE9NRVJfVEFCTEUpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRBdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZmV0Y2hpbmcgY3VzdG9tZXJzIGZyb20gU3VwYWJhc2U6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnVXNpbmcgbW9jayBjdXN0b21lciBkYXRhIGFzIGZhbGxiYWNrJyk7XG4gICAgICAgIHJldHVybiBNT0NLX0NVU1RPTUVSUztcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkICR7ZGF0YS5sZW5ndGh9IGN1c3RvbWVycyBmcm9tIGRhdGFiYXNlYCk7XG4gICAgICAgIHJldHVybiBkYXRhIGFzIEN1c3RvbWVyW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gY3VzdG9tZXJzIGZvdW5kIGluIGRhdGFiYXNlLCB1c2luZyBtb2NrIGRhdGEnKTtcbiAgICAgICAgcmV0dXJuIE1PQ0tfQ1VTVE9NRVJTO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDdXN0b21lcnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE1PQ0tfQ1VTVE9NRVJTOyAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGEgaW4gY2FzZSBvZiBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgY3VzdG9tZXIgYnkgSUQgZnJvbSBkYXRhYmFzZSAoZmFsbGJhY2sgdG8gbW9jayBkYXRhIG9ubHkgaWYgZXJyb3IpXG4gIGdldEN1c3RvbWVyOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Q3VzdG9tZXIgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBjdXN0b21lciAke2lkfSBmcm9tIGRhdGFiYXNlLi4uYCk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgc3RyaW5nIElEIHRvIFVVSUQgZm9ybWF0IGZvciBkYXRhYmFzZSBpZiBuZWVkZWRcbiAgICAgIGxldCBxdWVyeUlkID0gaWQ7XG4gICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBtb2NrIGRhdGEgSURzICgnMScsICcyJywgJzMnKVxuICAgICAgICAvLyBiZWluZyB1c2VkIGJlZm9yZSBtaWdyYXRpb24gdG8gZGF0YWJhc2VcbiAgICAgICAgcXVlcnlJZCA9IGAwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMCR7aWR9YDtcbiAgICAgICAgY29uc29sZS5sb2coYENvbnZlcnRpbmcgc2ltcGxlIElEICR7aWR9IHRvIFVVSUQgZm9ybWF0OiAke3F1ZXJ5SWR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHF1ZXJ5SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZmV0Y2hpbmcgY3VzdG9tZXIgJHtpZH06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIGZpbmQgaW4gbW9jayBkYXRhIGlmIGRhdGFiYXNlIHF1ZXJ5IGZhaWxlZFxuICAgICAgICBjb25zdCBtb2NrQ3VzdG9tZXIgPSBNT0NLX0NVU1RPTUVSUy5maW5kKGMgPT4gYy5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAobW9ja0N1c3RvbWVyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGN1c3RvbWVyICR7aWR9IGluIG1vY2sgZGF0YWApO1xuICAgICAgICAgIHJldHVybiBtb2NrQ3VzdG9tZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGN1c3RvbWVyICR7aWR9IGZyb20gZGF0YWJhc2VgKTtcbiAgICAgIHJldHVybiBkYXRhIGFzIEN1c3RvbWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBnZXRDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICAvLyBMYXN0IHJlc29ydCBmYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IG1vY2tDdXN0b21lciA9IE1PQ0tfQ1VTVE9NRVJTLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgICByZXR1cm4gbW9ja0N1c3RvbWVyIHx8IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8vIENyZWF0ZSBuZXcgY3VzdG9tZXJcbiAgY3JlYXRlQ3VzdG9tZXI6IGFzeW5jIChjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgdGltZXN0YW1wc1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgY29uc3QgbmV3Q3VzdG9tZXIgPSB7XG4gICAgICAgIC4uLmN1c3RvbWVyLFxuICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgdXBkYXRlZEF0OiBub3dcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBuZXcgY3VzdG9tZXIgaW4gZGF0YWJhc2U6JywgeyAuLi5uZXdDdXN0b21lciwgZW1haWw6IGN1c3RvbWVyLmVtYWlsIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLmluc2VydChbbmV3Q3VzdG9tZXJdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY3VzdG9tZXI6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnMjM1MDUnKSB7IC8vIFVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b21lciB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIGN1c3RvbWVyIHdpdGggSUQ6JywgZGF0YS5pZCk7XG4gICAgICByZXR1cm4gZGF0YSBhcyBDdXN0b21lcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlQ3VzdG9tZXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGFsbG93IHByb3BlciBlcnJvciBoYW5kbGluZyBpbiBVSVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgY3VzdG9tZXJcbiAgdXBkYXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nLCBjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgdXBkYXRlZCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IHVwZGF0ZWRDdXN0b21lciA9IHtcbiAgICAgICAgLi4uY3VzdG9tZXIsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVkQ3VzdG9tZXIpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHVwZGF0ZUN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvLyBEZWxldGUgY3VzdG9tZXJcbiAgZGVsZXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBkZWxldGVDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiQ1VTVE9NRVJfVEFCTEUiLCJNT0NLX0NVU1RPTUVSUyIsImlkIiwibmFtZSIsImVtYWlsIiwicGhvbmUiLCJhZGRyZXNzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiaXNBY3RpdmUiLCJDdXN0b21lckFQSSIsImdldEN1c3RvbWVycyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJ3YXJuIiwibWVzc2FnZSIsImluZm8iLCJsZW5ndGgiLCJnZXRDdXN0b21lciIsInF1ZXJ5SWQiLCJlcSIsInNpbmdsZSIsIm1vY2tDdXN0b21lciIsImZpbmQiLCJjIiwiY3JlYXRlQ3VzdG9tZXIiLCJjdXN0b21lciIsIm5vdyIsIm5ld0N1c3RvbWVyIiwiaW5zZXJ0IiwiY29kZSIsIkVycm9yIiwidXBkYXRlQ3VzdG9tZXIiLCJ1cGRhdGVkQ3VzdG9tZXIiLCJ1cGRhdGUiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/api/customer/customer-api.ts\n"));

/***/ })

});