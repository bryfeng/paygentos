"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/new/page",{

/***/ "(app-pages-browser)/./src/api/customer/customer-api.ts":
/*!******************************************!*\
  !*** ./src/api/customer/customer-api.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerAPI: () => (/* binding */ CustomerAPI)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n// API client for customer endpoints\n\n// Table name in Supabase\nconst CUSTOMER_TABLE = 'customers';\n// Helper function to convert snake_case to camelCase (for API responses)\nfunction toCamelCase(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(toCamelCase);\n    }\n    return Object.keys(obj).reduce((result, key)=>{\n        // Convert snake_case to camelCase\n        const camelKey = key.replace(/(_[a-z])/g, (group)=>group.toUpperCase().replace('_', ''));\n        // Recursively convert nested objects/arrays\n        const value = typeof obj[key] === 'object' ? toCamelCase(obj[key]) : obj[key];\n        result[camelKey] = value;\n        return result;\n    }, {});\n}\nconst CustomerAPI = {\n    // Get all customers from the database\n    getCustomers: async ()=>{\n        try {\n            console.log('Fetching customers from database...');\n            // Use created_at (snake_case) for the database query\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').order('created_at', {\n                ascending: false\n            });\n            if (error) {\n                console.error('Error fetching customers from Supabase:', error.message);\n                throw new Error(\"Failed to fetch customers: \".concat(error.message));\n            }\n            // Return actual database results, even if empty array\n            console.log(\"Retrieved \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" customers from database\"));\n            // Convert snake_case properties to camelCase\n            return (data || []).map((customer)=>toCamelCase(customer));\n        } catch (error) {\n            console.error('Error in getCustomers:', error);\n            throw error; // Re-throw to let component handle the error\n        }\n    },\n    // Get customer by ID from database\n    getCustomer: async (id)=>{\n        try {\n            console.log(\"Fetching customer \".concat(id, \" from database...\"));\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', id).single();\n            if (error) {\n                console.warn(\"Error fetching customer \".concat(id, \":\"), error.message);\n                if (error.code === 'PGRST116') {\n                    return null;\n                }\n                throw new Error(\"Failed to fetch customer: \".concat(error.message));\n            }\n            console.log(\"Successfully retrieved customer \".concat(id, \" from database\"));\n            // Convert snake_case properties to camelCase\n            return toCamelCase(data);\n        } catch (error) {\n            console.error(\"Error in getCustomer(\".concat(id, \"):\"), error);\n            throw error; // Re-throw to let component handle the error\n        }\n    },\n    // Create new customer\n    createCustomer: async (customer)=>{\n        try {\n            var _customer_contacts, _customer_idDocuments;\n            // Find primary contact for logging\n            const primaryContact = (_customer_contacts = customer.contacts) === null || _customer_contacts === void 0 ? void 0 : _customer_contacts.find((c)=>c.isPrimary);\n            const contactInfo = primaryContact ? \"\".concat(primaryContact.type, \": \").concat(primaryContact.value) : 'No primary contact';\n            console.log('Creating new customer via API route:', {\n                name: customer.fullName || \"\".concat(customer.firstName, \" \").concat(customer.lastName),\n                contact: contactInfo,\n                document_count: ((_customer_idDocuments = customer.idDocuments) === null || _customer_idDocuments === void 0 ? void 0 : _customer_idDocuments.length) || 0\n            });\n            // Call our Next.js API route instead of Supabase directly\n            // This avoids CORS issues since the API route runs server-side\n            const response = await fetch('/api/customers', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(customer)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Error response from API:', errorData);\n                throw new Error(errorData.error || 'Failed to create customer');\n            }\n            const data = await response.json();\n            console.log('Successfully created customer with ID:', data.id);\n            return data;\n        } catch (error) {\n            console.error('Error in createCustomer:', error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Update customer\n    updateCustomer: async (id, customer)=>{\n        try {\n            // First get the existing customer to ensure we don't lose data\n            const { data: existingCustomer, error: fetchError } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', id).single();\n            if (fetchError) {\n                console.error(\"Error fetching existing customer \".concat(id, \":\"), fetchError.message);\n                throw fetchError;\n            }\n            // Generate full name if first or last name is being updated\n            let fullName = customer.fullName;\n            var _customer_firstName;\n            const firstName = (_customer_firstName = customer.firstName) !== null && _customer_firstName !== void 0 ? _customer_firstName : existingCustomer.firstName;\n            var _customer_lastName;\n            const lastName = (_customer_lastName = customer.lastName) !== null && _customer_lastName !== void 0 ? _customer_lastName : existingCustomer.lastName;\n            if (!fullName && firstName && lastName) {\n                fullName = \"\".concat(firstName, \" \").concat(lastName);\n            }\n            // Handle contacts array merging if provided\n            let contacts = existingCustomer.contacts || [];\n            if (customer.contacts) {\n                contacts = customer.contacts;\n                // Ensure at least one contact is primary if there are contacts\n                if (contacts.length > 0 && !contacts.some((c)=>c.isPrimary)) {\n                    contacts[0].isPrimary = true;\n                }\n            }\n            var _customer_idDocuments;\n            // Handle ID documents array merging if provided\n            const idDocuments = (_customer_idDocuments = customer.idDocuments) !== null && _customer_idDocuments !== void 0 ? _customer_idDocuments : existingCustomer.idDocuments || [];\n            // Prepare the updated customer object\n            const updatedCustomer = {\n                ...existingCustomer,\n                ...customer,\n                fullName: fullName || existingCustomer.fullName,\n                contacts,\n                idDocuments,\n                updatedAt: new Date().toISOString()\n            };\n            // Find primary contact for logging\n            const primaryContact = contacts.find((c)=>c.isPrimary);\n            const contactInfo = primaryContact ? \"\".concat(primaryContact.type, \": \").concat(primaryContact.value) : 'No primary contact';\n            console.log(\"Updating customer \".concat(id, \":\"), {\n                name: updatedCustomer.fullName,\n                contact: contactInfo,\n                document_count: idDocuments.length\n            });\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).update(updatedCustomer).eq('id', id).select().single();\n            if (error) {\n                console.error(\"Error updating customer \".concat(id, \":\"), error.message);\n                throw error;\n            }\n            console.log(\"Successfully updated customer \".concat(id));\n            return data;\n        } catch (error) {\n            console.error(\"Error in updateCustomer \".concat(id, \":\"), error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Delete customer\n    deleteCustomer: async (id)=>{\n        try {\n            const { error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).delete().eq('id', id);\n            if (error) {\n                console.error(\"Error deleting customer \".concat(id, \":\"), error.message);\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in deleteCustomer \".concat(id, \":\"), error);\n            return false;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0NBQW9DO0FBUXVCO0FBRTNELHlCQUF5QjtBQUN6QixNQUFNQyxpQkFBaUI7QUFFdkIseUVBQXlFO0FBQ3pFLFNBQVNDLFlBQVlDLEdBQVE7SUFDM0IsSUFBSUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtRQUMzQyxPQUFPQTtJQUNUO0lBRUEsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixNQUFNO1FBQ3RCLE9BQU9BLElBQUlHLEdBQUcsQ0FBQ0o7SUFDakI7SUFFQSxPQUFPSyxPQUFPQyxJQUFJLENBQUNMLEtBQUtNLE1BQU0sQ0FBQyxDQUFDQyxRQUFRQztRQUN0QyxrQ0FBa0M7UUFDbEMsTUFBTUMsV0FBV0QsSUFBSUUsT0FBTyxDQUFDLGFBQWEsQ0FBQ0MsUUFBVUEsTUFBTUMsV0FBVyxHQUFHRixPQUFPLENBQUMsS0FBSztRQUV0Riw0Q0FBNEM7UUFDNUMsTUFBTUcsUUFBUSxPQUFPYixHQUFHLENBQUNRLElBQUksS0FBSyxXQUFXVCxZQUFZQyxHQUFHLENBQUNRLElBQUksSUFBSVIsR0FBRyxDQUFDUSxJQUFJO1FBRTdFRCxNQUFNLENBQUNFLFNBQVMsR0FBR0k7UUFDbkIsT0FBT047SUFDVCxHQUFHLENBQUM7QUFDTjtBQUVPLE1BQU1PLGNBQWM7SUFDekIsc0NBQXNDO0lBQ3RDQyxjQUFjO1FBQ1osSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixxREFBcUQ7WUFDckQsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU10QixxREFBUUEsQ0FDbkN1QixJQUFJLENBQUN0QixnQkFDTHVCLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsY0FBYztnQkFBRUMsV0FBVztZQUFNO1lBRTFDLElBQUlKLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQ0FBMkNBLE1BQU1LLE9BQU87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QUMvRDtJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCaUQsZ0JBQWdCLE9BQU92QztRQUNyQixJQUFJO1lBQ0YsTUFBTSxFQUFFVixLQUFLLEVBQUUsR0FBRyxNQUFNdEIscURBQVFBLENBQzdCdUIsSUFBSSxDQUFDdEIsZ0JBQ0x1RSxNQUFNLEdBQ052QyxFQUFFLENBQUMsTUFBTUQ7WUFFWixJQUFJVixPQUFPO2dCQUNUSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhVLElBQUcsTUFBSVYsTUFBTUssT0FBTztnQkFDN0QsT0FBTztZQUNUO1lBRUEsT0FBTztRQUNULEVBQUUsT0FBT0wsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhVLElBQUcsTUFBSVY7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW5mZW5nL3BheW1lbnQtYWdlbnQtcGxhdGZvcm0vc3JjL2FwaS9jdXN0b21lci9jdXN0b21lci1hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIGNsaWVudCBmb3IgY3VzdG9tZXIgZW5kcG9pbnRzXG5pbXBvcnQgeyBcbiAgQ3VzdG9tZXIsIFxuICBDb250YWN0VHlwZSwgXG4gIElkRG9jdW1lbnRUeXBlLCBcbiAgQ29udGFjdEluZm8sIFxuICBJZERvY3VtZW50IFxufSBmcm9tICcuLi8uLi9tb2RlbHMvY3VzdG9tZXIvY3VzdG9tZXInO1xuaW1wb3J0IHsgc3VwYWJhc2UsIHNhZmVRdWVyeSB9IGZyb20gJy4uLy4uL3V0aWxzL3N1cGFiYXNlJztcblxuLy8gVGFibGUgbmFtZSBpbiBTdXBhYmFzZVxuY29uc3QgQ1VTVE9NRVJfVEFCTEUgPSAnY3VzdG9tZXJzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgc25ha2VfY2FzZSB0byBjYW1lbENhc2UgKGZvciBBUEkgcmVzcG9uc2VzKVxuZnVuY3Rpb24gdG9DYW1lbENhc2Uob2JqOiBhbnkpOiBhbnkge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKHRvQ2FtZWxDYXNlKTtcbiAgfVxuICBcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgIC8vIENvbnZlcnQgc25ha2VfY2FzZSB0byBjYW1lbENhc2VcbiAgICBjb25zdCBjYW1lbEtleSA9IGtleS5yZXBsYWNlKC8oX1thLXpdKS9nLCAoZ3JvdXApID0+IGdyb3VwLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnXycsICcnKSk7XG4gICAgXG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCBuZXN0ZWQgb2JqZWN0cy9hcnJheXNcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcgPyB0b0NhbWVsQ2FzZShvYmpba2V5XSkgOiBvYmpba2V5XTtcbiAgICBcbiAgICByZXN1bHRbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30gYXMgYW55KTtcbn1cblxuZXhwb3J0IGNvbnN0IEN1c3RvbWVyQVBJID0ge1xuICAvLyBHZXQgYWxsIGN1c3RvbWVycyBmcm9tIHRoZSBkYXRhYmFzZVxuICBnZXRDdXN0b21lcnM6IGFzeW5jICgpOiBQcm9taXNlPEN1c3RvbWVyW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGN1c3RvbWVycyBmcm9tIGRhdGFiYXNlLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBjcmVhdGVkX2F0IChzbmFrZV9jYXNlKSBmb3IgdGhlIGRhdGFiYXNlIHF1ZXJ5XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGN1c3RvbWVycyBmcm9tIFN1cGFiYXNlOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjdXN0b21lcnM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGFjdHVhbCBkYXRhYmFzZSByZXN1bHRzLCBldmVuIGlmIGVtcHR5IGFycmF5XG4gICAgICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGN1c3RvbWVycyBmcm9tIGRhdGFiYXNlYCk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgc25ha2VfY2FzZSBwcm9wZXJ0aWVzIHRvIGNhbWVsQ2FzZVxuICAgICAgcmV0dXJuIChkYXRhIHx8IFtdKS5tYXAoY3VzdG9tZXIgPT4gdG9DYW1lbENhc2UoY3VzdG9tZXIpKSBhcyBDdXN0b21lcltdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDdXN0b21lcnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGxldCBjb21wb25lbnQgaGFuZGxlIHRoZSBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgY3VzdG9tZXIgYnkgSUQgZnJvbSBkYXRhYmFzZVxuICBnZXRDdXN0b21lcjogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgY3VzdG9tZXIgJHtpZH0gZnJvbSBkYXRhYmFzZS4uLmApO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBmZXRjaGluZyBjdXN0b21lciAke2lkfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHsgLy8gcmVjb3JkIG5vdCBmb3VuZFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGN1c3RvbWVyOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGN1c3RvbWVyICR7aWR9IGZyb20gZGF0YWJhc2VgKTtcbiAgICAgIC8vIENvbnZlcnQgc25ha2VfY2FzZSBwcm9wZXJ0aWVzIHRvIGNhbWVsQ2FzZVxuICAgICAgcmV0dXJuIHRvQ2FtZWxDYXNlKGRhdGEpIGFzIEN1c3RvbWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBnZXRDdXN0b21lcigke2lkfSk6YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGxldCBjb21wb25lbnQgaGFuZGxlIHRoZSBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBDcmVhdGUgbmV3IGN1c3RvbWVyXG4gIGNyZWF0ZUN1c3RvbWVyOiBhc3luYyAoY3VzdG9tZXI6IFBhcnRpYWw8Q3VzdG9tZXI+KTogUHJvbWlzZTxDdXN0b21lciB8IG51bGw+ID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmluZCBwcmltYXJ5IGNvbnRhY3QgZm9yIGxvZ2dpbmdcbiAgICAgIGNvbnN0IHByaW1hcnlDb250YWN0ID0gY3VzdG9tZXIuY29udGFjdHM/LmZpbmQoYyA9PiBjLmlzUHJpbWFyeSk7XG4gICAgICBjb25zdCBjb250YWN0SW5mbyA9IHByaW1hcnlDb250YWN0ID8gYCR7cHJpbWFyeUNvbnRhY3QudHlwZX06ICR7cHJpbWFyeUNvbnRhY3QudmFsdWV9YCA6ICdObyBwcmltYXJ5IGNvbnRhY3QnO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGN1c3RvbWVyIHZpYSBBUEkgcm91dGU6JywgeyBcbiAgICAgICAgbmFtZTogY3VzdG9tZXIuZnVsbE5hbWUgfHwgYCR7Y3VzdG9tZXIuZmlyc3ROYW1lfSAke2N1c3RvbWVyLmxhc3ROYW1lfWAsXG4gICAgICAgIGNvbnRhY3Q6IGNvbnRhY3RJbmZvLFxuICAgICAgICBkb2N1bWVudF9jb3VudDogY3VzdG9tZXIuaWREb2N1bWVudHM/Lmxlbmd0aCB8fCAwXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2FsbCBvdXIgTmV4dC5qcyBBUEkgcm91dGUgaW5zdGVhZCBvZiBTdXBhYmFzZSBkaXJlY3RseVxuICAgICAgLy8gVGhpcyBhdm9pZHMgQ09SUyBpc3N1ZXMgc2luY2UgdGhlIEFQSSByb3V0ZSBydW5zIHNlcnZlci1zaWRlXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2N1c3RvbWVycycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjdXN0b21lciksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc3BvbnNlIGZyb20gQVBJOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgY3VzdG9tZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgY3JlYXRlZCBjdXN0b21lciB3aXRoIElEOicsIGRhdGEuaWQpO1xuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlQ3VzdG9tZXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGFsbG93IHByb3BlciBlcnJvciBoYW5kbGluZyBpbiBVSVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgY3VzdG9tZXJcbiAgdXBkYXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nLCBjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBnZXQgdGhlIGV4aXN0aW5nIGN1c3RvbWVyIHRvIGVuc3VyZSB3ZSBkb24ndCBsb3NlIGRhdGFcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdDdXN0b21lciwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGV4aXN0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGZldGNoRXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIGZ1bGwgbmFtZSBpZiBmaXJzdCBvciBsYXN0IG5hbWUgaXMgYmVpbmcgdXBkYXRlZFxuICAgICAgbGV0IGZ1bGxOYW1lID0gY3VzdG9tZXIuZnVsbE5hbWU7XG4gICAgICBjb25zdCBmaXJzdE5hbWUgPSBjdXN0b21lci5maXJzdE5hbWUgPz8gZXhpc3RpbmdDdXN0b21lci5maXJzdE5hbWU7XG4gICAgICBjb25zdCBsYXN0TmFtZSA9IGN1c3RvbWVyLmxhc3ROYW1lID8/IGV4aXN0aW5nQ3VzdG9tZXIubGFzdE5hbWU7XG4gICAgICBcbiAgICAgIGlmICghZnVsbE5hbWUgJiYgZmlyc3ROYW1lICYmIGxhc3ROYW1lKSB7XG4gICAgICAgIGZ1bGxOYW1lID0gYCR7Zmlyc3ROYW1lfSAke2xhc3ROYW1lfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjb250YWN0cyBhcnJheSBtZXJnaW5nIGlmIHByb3ZpZGVkXG4gICAgICBsZXQgY29udGFjdHMgPSBleGlzdGluZ0N1c3RvbWVyLmNvbnRhY3RzIHx8IFtdO1xuICAgICAgaWYgKGN1c3RvbWVyLmNvbnRhY3RzKSB7XG4gICAgICAgIGNvbnRhY3RzID0gY3VzdG9tZXIuY29udGFjdHM7XG4gICAgICAgIFxuICAgICAgICAvLyBFbnN1cmUgYXQgbGVhc3Qgb25lIGNvbnRhY3QgaXMgcHJpbWFyeSBpZiB0aGVyZSBhcmUgY29udGFjdHNcbiAgICAgICAgaWYgKGNvbnRhY3RzLmxlbmd0aCA+IDAgJiYgIWNvbnRhY3RzLnNvbWUoYyA9PiBjLmlzUHJpbWFyeSkpIHtcbiAgICAgICAgICBjb250YWN0c1swXS5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBJRCBkb2N1bWVudHMgYXJyYXkgbWVyZ2luZyBpZiBwcm92aWRlZFxuICAgICAgY29uc3QgaWREb2N1bWVudHMgPSBjdXN0b21lci5pZERvY3VtZW50cyA/PyAoZXhpc3RpbmdDdXN0b21lci5pZERvY3VtZW50cyB8fCBbXSk7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHVwZGF0ZWQgY3VzdG9tZXIgb2JqZWN0XG4gICAgICBjb25zdCB1cGRhdGVkQ3VzdG9tZXIgPSB7XG4gICAgICAgIC4uLmV4aXN0aW5nQ3VzdG9tZXIsXG4gICAgICAgIC4uLmN1c3RvbWVyLFxuICAgICAgICBmdWxsTmFtZTogZnVsbE5hbWUgfHwgZXhpc3RpbmdDdXN0b21lci5mdWxsTmFtZSxcbiAgICAgICAgY29udGFjdHMsXG4gICAgICAgIGlkRG9jdW1lbnRzLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgLy8gRmluZCBwcmltYXJ5IGNvbnRhY3QgZm9yIGxvZ2dpbmdcbiAgICAgIGNvbnN0IHByaW1hcnlDb250YWN0ID0gY29udGFjdHMuZmluZChjID0+IGMuaXNQcmltYXJ5KTtcbiAgICAgIGNvbnN0IGNvbnRhY3RJbmZvID0gcHJpbWFyeUNvbnRhY3QgXG4gICAgICAgID8gYCR7cHJpbWFyeUNvbnRhY3QudHlwZX06ICR7cHJpbWFyeUNvbnRhY3QudmFsdWV9YCBcbiAgICAgICAgOiAnTm8gcHJpbWFyeSBjb250YWN0JztcblxuICAgICAgY29uc29sZS5sb2coYFVwZGF0aW5nIGN1c3RvbWVyICR7aWR9OmAsIHtcbiAgICAgICAgbmFtZTogdXBkYXRlZEN1c3RvbWVyLmZ1bGxOYW1lLFxuICAgICAgICBjb250YWN0OiBjb250YWN0SW5mbyxcbiAgICAgICAgZG9jdW1lbnRfY291bnQ6IGlkRG9jdW1lbnRzLmxlbmd0aFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZWRDdXN0b21lcilcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgY3VzdG9tZXIgJHtpZH06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgY3VzdG9tZXIgJHtpZH1gKTtcbiAgICAgIHJldHVybiBkYXRhIGFzIEN1c3RvbWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiB1cGRhdGVDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdG8gYWxsb3cgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGluIFVJXG4gICAgfVxuICB9LFxuXG4gIC8vIERlbGV0ZSBjdXN0b21lclxuICBkZWxldGVDdXN0b21lcjogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oQ1VTVE9NRVJfVEFCTEUpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgaWQpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgY3VzdG9tZXIgJHtpZH06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGRlbGV0ZUN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJDVVNUT01FUl9UQUJMRSIsInRvQ2FtZWxDYXNlIiwib2JqIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsInJlc3VsdCIsImtleSIsImNhbWVsS2V5IiwicmVwbGFjZSIsImdyb3VwIiwidG9VcHBlckNhc2UiLCJ2YWx1ZSIsIkN1c3RvbWVyQVBJIiwiZ2V0Q3VzdG9tZXJzIiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsIm1lc3NhZ2UiLCJFcnJvciIsImxlbmd0aCIsImN1c3RvbWVyIiwiZ2V0Q3VzdG9tZXIiLCJpZCIsImVxIiwic2luZ2xlIiwid2FybiIsImNvZGUiLCJjcmVhdGVDdXN0b21lciIsInByaW1hcnlDb250YWN0IiwiY29udGFjdHMiLCJmaW5kIiwiYyIsImlzUHJpbWFyeSIsImNvbnRhY3RJbmZvIiwidHlwZSIsIm5hbWUiLCJmdWxsTmFtZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiY29udGFjdCIsImRvY3VtZW50X2NvdW50IiwiaWREb2N1bWVudHMiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwidXBkYXRlQ3VzdG9tZXIiLCJleGlzdGluZ0N1c3RvbWVyIiwiZmV0Y2hFcnJvciIsInNvbWUiLCJ1cGRhdGVkQ3VzdG9tZXIiLCJ1cGRhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGUiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/api/customer/customer-api.ts\n"));

/***/ })

});