"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/new/page",{

/***/ "(app-pages-browser)/./src/models/customer/customer.ts":
/*!*****************************************!*\
  !*** ./src/models/customer/customer.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactType: () => (/* binding */ ContactType),\n/* harmony export */   IdDocumentType: () => (/* binding */ IdDocumentType),\n/* harmony export */   defaultCustomer: () => (/* binding */ defaultCustomer),\n/* harmony export */   getContactByType: () => (/* binding */ getContactByType),\n/* harmony export */   getFullName: () => (/* binding */ getFullName),\n/* harmony export */   getPrimaryContact: () => (/* binding */ getPrimaryContact),\n/* harmony export */   validateCustomer: () => (/* binding */ validateCustomer)\n/* harmony export */ });\n// Contact type enum\nvar ContactType = /*#__PURE__*/ function(ContactType) {\n    ContactType[\"EMAIL\"] = \"email\";\n    ContactType[\"PHONE\"] = \"phone\";\n    ContactType[\"TELEGRAM\"] = \"telegram\";\n    ContactType[\"SLACK\"] = \"slack\";\n    ContactType[\"DISCORD\"] = \"discord\";\n    ContactType[\"WHATSAPP\"] = \"whatsapp\";\n    ContactType[\"SIGNAL\"] = \"signal\";\n    ContactType[\"OTHER\"] = \"other\";\n    return ContactType;\n}({});\n// ID document type enum\nvar IdDocumentType = /*#__PURE__*/ function(IdDocumentType) {\n    IdDocumentType[\"PASSPORT\"] = \"passport\";\n    IdDocumentType[\"DRIVERS_LICENSE\"] = \"drivers_license\";\n    IdDocumentType[\"NATIONAL_ID\"] = \"national_id\";\n    IdDocumentType[\"RESIDENCE_PERMIT\"] = \"residence_permit\";\n    IdDocumentType[\"SOCIAL_SECURITY\"] = \"social_security\";\n    IdDocumentType[\"TAX_ID\"] = \"tax_id\";\n    IdDocumentType[\"OTHER\"] = \"other\";\n    return IdDocumentType;\n}({});\n// Default values for new customer\nconst defaultCustomer = {\n    contacts: [],\n    preferredContactType: \"email\",\n    idDocuments: [],\n    isActive: true,\n    createdAt: new Date(),\n    updatedAt: new Date()\n};\n// Customer validation\nconst validateCustomer = (customer)=>{\n    const errors = [];\n    if (!customer.firstName) {\n        errors.push('First name is required');\n    }\n    if (!customer.lastName) {\n        errors.push('Last name is required');\n    }\n    // Check if at least one contact method exists\n    if (!customer.contacts || customer.contacts.length === 0) {\n        errors.push('At least one contact method is required');\n    } else {\n        // Find email contact(s)\n        const emailContacts = customer.contacts.filter((c)=>c.type === \"email\" && c.value.trim() !== '');\n        if (emailContacts.length === 0) {\n            errors.push('An email address is required');\n        }\n        // Validate that the primary contact information is properly formatted\n        const primaryContact = customer.contacts.find((c)=>c.isPrimary);\n        if (!primaryContact) {\n            errors.push('At least one contact method must be marked as primary');\n        } else if (primaryContact.type === \"email\" && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(primaryContact.value)) {\n            errors.push('Primary email format is invalid');\n        }\n        // Validate all email contacts have proper format\n        for (const contact of emailContacts){\n            if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(contact.value)) {\n                errors.push(\"Email address '\".concat(contact.value, \"' is invalid\"));\n            }\n        }\n    }\n    // Validate date of birth if provided\n    if (customer.dob) {\n        const dobDate = new Date(customer.dob);\n        const today = new Date();\n        if (isNaN(dobDate.getTime())) {\n            errors.push('Date of birth is invalid');\n        } else if (dobDate > today) {\n            errors.push('Date of birth cannot be in the future');\n        }\n    }\n    return errors;\n};\n// Utility function to get primary contact\nconst getPrimaryContact = (customer)=>{\n    return customer.contacts.find((contact)=>contact.isPrimary);\n};\n// Utility function to get contact by type\nconst getContactByType = (customer, type)=>{\n    return customer.contacts.find((contact)=>contact.type === type);\n};\n// Utility function to get full name\nconst getFullName = (customer)=>{\n    return customer.fullName || \"\".concat(customer.firstName, \" \").concat(customer.lastName);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tb2RlbHMvY3VzdG9tZXIvY3VzdG9tZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUNiLHlDQUFLQTs7Ozs7Ozs7O1dBQUFBO01BU1g7QUFFRCx3QkFBd0I7QUFDakIsNENBQUtDOzs7Ozs7OztXQUFBQTtNQVFYO0FBdURELGtDQUFrQztBQUMzQixNQUFNQyxrQkFBcUM7SUFDaERDLFVBQVUsRUFBRTtJQUNaQyxvQkFBb0I7SUFDcEJDLGFBQWEsRUFBRTtJQUNmQyxVQUFVO0lBQ1ZDLFdBQVcsSUFBSUM7SUFDZkMsV0FBVyxJQUFJRDtBQUNqQixFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTUUsbUJBQW1CLENBQUNDO0lBQy9CLE1BQU1DLFNBQW1CLEVBQUU7SUFFM0IsSUFBSSxDQUFDRCxTQUFTRSxTQUFTLEVBQUU7UUFDdkJELE9BQU9FLElBQUksQ0FBQztJQUNkO0lBRUEsSUFBSSxDQUFDSCxTQUFTSSxRQUFRLEVBQUU7UUFDdEJILE9BQU9FLElBQUksQ0FBQztJQUNkO0lBRUEsOENBQThDO0lBQzlDLElBQUksQ0FBQ0gsU0FBU1IsUUFBUSxJQUFJUSxTQUFTUixRQUFRLENBQUNhLE1BQU0sS0FBSyxHQUFHO1FBQ3hESixPQUFPRSxJQUFJLENBQUM7SUFDZCxPQUFPO1FBQ0wsd0JBQXdCO1FBQ3hCLE1BQU1HLGdCQUFnQk4sU0FBU1IsUUFBUSxDQUFDZSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUksZ0JBQTBCRCxFQUFFRSxLQUFLLENBQUNDLElBQUksT0FBTztRQUV2RyxJQUFJTCxjQUFjRCxNQUFNLEtBQUssR0FBRztZQUM5QkosT0FBT0UsSUFBSSxDQUFDO1FBQ2Q7UUFFQSxzRUFBc0U7UUFDdEUsTUFBTVMsaUJBQWlCWixTQUFTUixRQUFRLENBQUNxQixJQUFJLENBQUNMLENBQUFBLElBQUtBLEVBQUVNLFNBQVM7UUFDOUQsSUFBSSxDQUFDRixnQkFBZ0I7WUFDbkJYLE9BQU9FLElBQUksQ0FBQztRQUNkLE9BQU8sSUFBSVMsZUFBZUgsSUFBSSxnQkFBMEIsQ0FBQyw2QkFBNkJNLElBQUksQ0FBQ0gsZUFBZUYsS0FBSyxHQUFHO1lBQ2hIVCxPQUFPRSxJQUFJLENBQUM7UUFDZDtRQUVBLGlEQUFpRDtRQUNqRCxLQUFLLE1BQU1hLFdBQVdWLGNBQWU7WUFDbkMsSUFBSSxDQUFDLDZCQUE2QlMsSUFBSSxDQUFDQyxRQUFRTixLQUFLLEdBQUc7Z0JBQ3JEVCxPQUFPRSxJQUFJLENBQUMsa0JBQWdDLE9BQWRhLFFBQVFOLEtBQUssRUFBQztZQUM5QztRQUNGO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMsSUFBSVYsU0FBU2lCLEdBQUcsRUFBRTtRQUNoQixNQUFNQyxVQUFVLElBQUlyQixLQUFLRyxTQUFTaUIsR0FBRztRQUNyQyxNQUFNRSxRQUFRLElBQUl0QjtRQUNsQixJQUFJdUIsTUFBTUYsUUFBUUcsT0FBTyxLQUFLO1lBQzVCcEIsT0FBT0UsSUFBSSxDQUFDO1FBQ2QsT0FBTyxJQUFJZSxVQUFVQyxPQUFPO1lBQzFCbEIsT0FBT0UsSUFBSSxDQUFDO1FBQ2Q7SUFDRjtJQUVBLE9BQU9GO0FBQ1QsRUFBRTtBQUVGLDBDQUEwQztBQUNuQyxNQUFNcUIsb0JBQW9CLENBQUN0QjtJQUNoQyxPQUFPQSxTQUFTUixRQUFRLENBQUNxQixJQUFJLENBQUNHLENBQUFBLFVBQVdBLFFBQVFGLFNBQVM7QUFDNUQsRUFBRTtBQUVGLDBDQUEwQztBQUNuQyxNQUFNUyxtQkFBbUIsQ0FBQ3ZCLFVBQW9CUztJQUNuRCxPQUFPVCxTQUFTUixRQUFRLENBQUNxQixJQUFJLENBQUNHLENBQUFBLFVBQVdBLFFBQVFQLElBQUksS0FBS0E7QUFDNUQsRUFBRTtBQUVGLG9DQUFvQztBQUM3QixNQUFNZSxjQUFjLENBQUN4QjtJQUMxQixPQUFPQSxTQUFTeUIsUUFBUSxJQUFJLEdBQXlCekIsT0FBdEJBLFNBQVNFLFNBQVMsRUFBQyxLQUFxQixPQUFsQkYsU0FBU0ksUUFBUTtBQUN4RSxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW5mZW5nL3BheW1lbnQtYWdlbnQtcGxhdGZvcm0vc3JjL21vZGVscy9jdXN0b21lci9jdXN0b21lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250YWN0IHR5cGUgZW51bVxuZXhwb3J0IGVudW0gQ29udGFjdFR5cGUge1xuICBFTUFJTCA9ICdlbWFpbCcsXG4gIFBIT05FID0gJ3Bob25lJyxcbiAgVEVMRUdSQU0gPSAndGVsZWdyYW0nLFxuICBTTEFDSyA9ICdzbGFjaycsXG4gIERJU0NPUkQgPSAnZGlzY29yZCcsXG4gIFdIQVRTQVBQID0gJ3doYXRzYXBwJyxcbiAgU0lHTkFMID0gJ3NpZ25hbCcsXG4gIE9USEVSID0gJ290aGVyJ1xufVxuXG4vLyBJRCBkb2N1bWVudCB0eXBlIGVudW1cbmV4cG9ydCBlbnVtIElkRG9jdW1lbnRUeXBlIHtcbiAgUEFTU1BPUlQgPSAncGFzc3BvcnQnLFxuICBEUklWRVJTX0xJQ0VOU0UgPSAnZHJpdmVyc19saWNlbnNlJyxcbiAgTkFUSU9OQUxfSUQgPSAnbmF0aW9uYWxfaWQnLFxuICBSRVNJREVOQ0VfUEVSTUlUID0gJ3Jlc2lkZW5jZV9wZXJtaXQnLFxuICBTT0NJQUxfU0VDVVJJVFkgPSAnc29jaWFsX3NlY3VyaXR5JyxcbiAgVEFYX0lEID0gJ3RheF9pZCcsXG4gIE9USEVSID0gJ290aGVyJ1xufVxuXG4vLyBDb250YWN0IGluZm9ybWF0aW9uIHR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdEluZm8ge1xuICB0eXBlOiBDb250YWN0VHlwZTtcbiAgdmFsdWU6IHN0cmluZztcbiAgaXNQcmltYXJ5PzogYm9vbGVhbjtcbiAgbGFiZWw/OiBzdHJpbmc7XG59XG5cbi8vIElEIGRvY3VtZW50IHR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgSWREb2N1bWVudCB7XG4gIHR5cGU6IElkRG9jdW1lbnRUeXBlO1xuICBudW1iZXI6IHN0cmluZztcbiAgaXNzdWVkQnk/OiBzdHJpbmc7XG4gIGlzc3VlZERhdGU/OiBzdHJpbmcgfCBEYXRlO1xuICBleHBpcnlEYXRlPzogc3RyaW5nIHwgRGF0ZTtcbiAgaXNWZXJpZmllZD86IGJvb2xlYW47XG59XG5cbi8vIEN1c3RvbWVyIE1vZGVsIC0gZm9jdXNlZCBvbiBpbmRpdmlkdWFsc1xuZXhwb3J0IGludGVyZmFjZSBDdXN0b21lciB7XG4gIGlkOiBzdHJpbmc7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBmdWxsTmFtZT86IHN0cmluZzsgICAgICAgLy8gQ29tcHV0ZWQgb3IgcHJvdmlkZWQgZnVsbCBuYW1lXG4gIGRvYj86IHN0cmluZyB8IERhdGU7ICAgICAvLyBEYXRlIG9mIGJpcnRoXG4gIC8vIEFkZHJlc3MgaW5mb3JtYXRpb25cbiAgYWRkcmVzcz86IHN0cmluZzsgICAgICAgIC8vIEZ1bGwgYWRkcmVzcyBvciBzdHJlZXQgYWRkcmVzc1xuICBjaXR5Pzogc3RyaW5nO1xuICBzdGF0ZT86IHN0cmluZztcbiAgcG9zdGFsQ29kZT86IHN0cmluZztcbiAgY291bnRyeT86IHN0cmluZztcbiAgLy8gQ29udGFjdCBpbmZvcm1hdGlvblxuICBjb250YWN0czogQ29udGFjdEluZm9bXTsgIC8vIEFycmF5IG9mIGRpZmZlcmVudCBjb250YWN0IG1ldGhvZHNcbiAgcHJlZmVycmVkQ29udGFjdFR5cGU/OiBDb250YWN0VHlwZTtcbiAgLy8gSWRlbnRpdHkgZG9jdW1lbnRzXG4gIGlkRG9jdW1lbnRzPzogSWREb2N1bWVudFtdO1xuICAvLyBTdGF0dXNcbiAgaXNBY3RpdmU/OiBib29sZWFuO1xuICAvLyBTeXN0ZW0gZmllbGRzXG4gIGNyZWF0ZWRBdDogc3RyaW5nIHwgRGF0ZTtcbiAgdXBkYXRlZEF0OiBzdHJpbmcgfCBEYXRlO1xuICAvLyBBZGRpdGlvbmFsIGZpZWxkc1xuICBub3Rlcz86IHN0cmluZztcbiAgdGFncz86IHN0cmluZ1tdO1xuICAvLyBMZWdhY3kgZmllbGRzIChjYW4gYmUgZGVwcmVjYXRlZCBvdmVyIHRpbWUpXG4gIGVtYWlsPzogc3RyaW5nOyAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIHBob25lPzogc3RyaW5nOyAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIC8vIEZvciBleHRlbnNpYmlsaXR5XG4gIG1ldGFkYXRhPzoge1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbn1cblxuLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIG5ldyBjdXN0b21lclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4gPSB7XG4gIGNvbnRhY3RzOiBbXSxcbiAgcHJlZmVycmVkQ29udGFjdFR5cGU6IENvbnRhY3RUeXBlLkVNQUlMLFxuICBpZERvY3VtZW50czogW10sXG4gIGlzQWN0aXZlOiB0cnVlLFxuICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbn07XG5cbi8vIEN1c3RvbWVyIHZhbGlkYXRpb25cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUN1c3RvbWVyID0gKGN1c3RvbWVyOiBQYXJ0aWFsPEN1c3RvbWVyPik6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKCFjdXN0b21lci5maXJzdE5hbWUpIHtcbiAgICBlcnJvcnMucHVzaCgnRmlyc3QgbmFtZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIFxuICBpZiAoIWN1c3RvbWVyLmxhc3ROYW1lKSB7XG4gICAgZXJyb3JzLnB1c2goJ0xhc3QgbmFtZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIFxuICAvLyBDaGVjayBpZiBhdCBsZWFzdCBvbmUgY29udGFjdCBtZXRob2QgZXhpc3RzXG4gIGlmICghY3VzdG9tZXIuY29udGFjdHMgfHwgY3VzdG9tZXIuY29udGFjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3JzLnB1c2goJ0F0IGxlYXN0IG9uZSBjb250YWN0IG1ldGhvZCBpcyByZXF1aXJlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgZW1haWwgY29udGFjdChzKVxuICAgIGNvbnN0IGVtYWlsQ29udGFjdHMgPSBjdXN0b21lci5jb250YWN0cy5maWx0ZXIoYyA9PiBjLnR5cGUgPT09IENvbnRhY3RUeXBlLkVNQUlMICYmIGMudmFsdWUudHJpbSgpICE9PSAnJyk7XG4gICAgXG4gICAgaWYgKGVtYWlsQ29udGFjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcnMucHVzaCgnQW4gZW1haWwgYWRkcmVzcyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcmltYXJ5IGNvbnRhY3QgaW5mb3JtYXRpb24gaXMgcHJvcGVybHkgZm9ybWF0dGVkXG4gICAgY29uc3QgcHJpbWFyeUNvbnRhY3QgPSBjdXN0b21lci5jb250YWN0cy5maW5kKGMgPT4gYy5pc1ByaW1hcnkpO1xuICAgIGlmICghcHJpbWFyeUNvbnRhY3QpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdBdCBsZWFzdCBvbmUgY29udGFjdCBtZXRob2QgbXVzdCBiZSBtYXJrZWQgYXMgcHJpbWFyeScpO1xuICAgIH0gZWxzZSBpZiAocHJpbWFyeUNvbnRhY3QudHlwZSA9PT0gQ29udGFjdFR5cGUuRU1BSUwgJiYgIS9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QocHJpbWFyeUNvbnRhY3QudmFsdWUpKSB7XG4gICAgICBlcnJvcnMucHVzaCgnUHJpbWFyeSBlbWFpbCBmb3JtYXQgaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBhbGwgZW1haWwgY29udGFjdHMgaGF2ZSBwcm9wZXIgZm9ybWF0XG4gICAgZm9yIChjb25zdCBjb250YWN0IG9mIGVtYWlsQ29udGFjdHMpIHtcbiAgICAgIGlmICghL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC8udGVzdChjb250YWN0LnZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChgRW1haWwgYWRkcmVzcyAnJHtjb250YWN0LnZhbHVlfScgaXMgaW52YWxpZGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gVmFsaWRhdGUgZGF0ZSBvZiBiaXJ0aCBpZiBwcm92aWRlZFxuICBpZiAoY3VzdG9tZXIuZG9iKSB7XG4gICAgY29uc3QgZG9iRGF0ZSA9IG5ldyBEYXRlKGN1c3RvbWVyLmRvYik7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGlmIChpc05hTihkb2JEYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdEYXRlIG9mIGJpcnRoIGlzIGludmFsaWQnKTtcbiAgICB9IGVsc2UgaWYgKGRvYkRhdGUgPiB0b2RheSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0RhdGUgb2YgYmlydGggY2Fubm90IGJlIGluIHRoZSBmdXR1cmUnKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBlcnJvcnM7XG59O1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBwcmltYXJ5IGNvbnRhY3RcbmV4cG9ydCBjb25zdCBnZXRQcmltYXJ5Q29udGFjdCA9IChjdXN0b21lcjogQ3VzdG9tZXIpOiBDb250YWN0SW5mbyB8IHVuZGVmaW5lZCA9PiB7XG4gIHJldHVybiBjdXN0b21lci5jb250YWN0cy5maW5kKGNvbnRhY3QgPT4gY29udGFjdC5pc1ByaW1hcnkpO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgY29udGFjdCBieSB0eXBlXG5leHBvcnQgY29uc3QgZ2V0Q29udGFjdEJ5VHlwZSA9IChjdXN0b21lcjogQ3VzdG9tZXIsIHR5cGU6IENvbnRhY3RUeXBlKTogQ29udGFjdEluZm8gfCB1bmRlZmluZWQgPT4ge1xuICByZXR1cm4gY3VzdG9tZXIuY29udGFjdHMuZmluZChjb250YWN0ID0+IGNvbnRhY3QudHlwZSA9PT0gdHlwZSk7XG59O1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBmdWxsIG5hbWVcbmV4cG9ydCBjb25zdCBnZXRGdWxsTmFtZSA9IChjdXN0b21lcjogQ3VzdG9tZXIpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gY3VzdG9tZXIuZnVsbE5hbWUgfHwgYCR7Y3VzdG9tZXIuZmlyc3ROYW1lfSAke2N1c3RvbWVyLmxhc3ROYW1lfWA7XG59O1xuIl0sIm5hbWVzIjpbIkNvbnRhY3RUeXBlIiwiSWREb2N1bWVudFR5cGUiLCJkZWZhdWx0Q3VzdG9tZXIiLCJjb250YWN0cyIsInByZWZlcnJlZENvbnRhY3RUeXBlIiwiaWREb2N1bWVudHMiLCJpc0FjdGl2ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1cGRhdGVkQXQiLCJ2YWxpZGF0ZUN1c3RvbWVyIiwiY3VzdG9tZXIiLCJlcnJvcnMiLCJmaXJzdE5hbWUiLCJwdXNoIiwibGFzdE5hbWUiLCJsZW5ndGgiLCJlbWFpbENvbnRhY3RzIiwiZmlsdGVyIiwiYyIsInR5cGUiLCJ2YWx1ZSIsInRyaW0iLCJwcmltYXJ5Q29udGFjdCIsImZpbmQiLCJpc1ByaW1hcnkiLCJ0ZXN0IiwiY29udGFjdCIsImRvYiIsImRvYkRhdGUiLCJ0b2RheSIsImlzTmFOIiwiZ2V0VGltZSIsImdldFByaW1hcnlDb250YWN0IiwiZ2V0Q29udGFjdEJ5VHlwZSIsImdldEZ1bGxOYW1lIiwiZnVsbE5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/models/customer/customer.ts\n"));

/***/ })

});