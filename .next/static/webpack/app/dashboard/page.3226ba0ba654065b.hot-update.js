"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/api/customer/customer-api.ts":
/*!******************************************!*\
  !*** ./src/api/customer/customer-api.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerAPI: () => (/* binding */ CustomerAPI)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n// API client for customer endpoints\n\n// Table name in Supabase\nconst CUSTOMER_TABLE = 'customers';\n// Mock data for development/fallback\nconst MOCK_CUSTOMERS = [\n    {\n        id: '1',\n        name: 'Acme Corporation',\n        email: 'contact@acme.com',\n        phone: '555-123-4567',\n        address: '123 Business Ave, Suite 100, New York, NY 10001',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '2',\n        name: 'Globex Industries',\n        email: 'info@globex.com',\n        phone: '555-987-6543',\n        address: '456 Corporate Blvd, Chicago, IL 60601',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '3',\n        name: 'Initech LLC',\n        email: 'support@initech.com',\n        phone: '555-456-7890',\n        address: '789 Tech Park, San Francisco, CA 94105',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    }\n];\nconst CustomerAPI = {\n    // Get all customers with fallback to mock data only if database fails\n    getCustomers: async ()=>{\n        try {\n            console.log('Fetching customers from database...');\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').order('createdAt', {\n                ascending: false\n            });\n            if (error) {\n                console.warn('Error fetching customers from Supabase:', error.message);\n                console.info('Using mock customer data as fallback');\n                return MOCK_CUSTOMERS;\n            }\n            // Return actual database results, even if empty array\n            // This ensures new customers added through admin panel will be shown\n            console.log(\"Retrieved \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" customers from database\"));\n            return data || [];\n        } catch (error) {\n            console.error('Error in getCustomers:', error);\n            return MOCK_CUSTOMERS; // Fallback to mock data in case of error\n        }\n    },\n    // Get customer by ID from database (fallback to mock data only if error)\n    getCustomer: async (id)=>{\n        try {\n            console.log(\"Fetching customer \".concat(id, \" from database...\"));\n            // Convert string ID to UUID format for database if needed\n            let queryId = id;\n            if (id.length === 1) {\n                // This handles the case of mock data IDs ('1', '2', '3')\n                // being used before migration to database\n                queryId = \"00000000-0000-0000-0000-00000000000\".concat(id);\n                console.log(\"Converting simple ID \".concat(id, \" to UUID format: \").concat(queryId));\n            }\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', queryId).single();\n            if (error) {\n                console.warn(\"Error fetching customer \".concat(id, \":\"), error.message);\n                // Only try to find in mock data if database query failed\n                const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n                if (mockCustomer) {\n                    console.log(\"Found customer \".concat(id, \" in mock data\"));\n                    return mockCustomer;\n                }\n                return null;\n            }\n            console.log(\"Successfully retrieved customer \".concat(id, \" from database\"));\n            return data;\n        } catch (error) {\n            console.error(\"Error in getCustomer \".concat(id, \":\"), error);\n            // Last resort fallback to mock data\n            const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n            return mockCustomer || null;\n        }\n    },\n    // Create new customer\n    createCustomer: async (customer)=>{\n        try {\n            // Add timestamps\n            const now = new Date().toISOString();\n            const newCustomer = {\n                ...customer,\n                createdAt: now,\n                updatedAt: now\n            };\n            console.log('Creating new customer in database:', {\n                ...newCustomer,\n                email: customer.email\n            });\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).insert([\n                newCustomer\n            ]).select().single();\n            if (error) {\n                console.error('Error creating customer:', error.message);\n                if (error.code === '23505') {\n                    throw new Error('A customer with this email already exists');\n                }\n                throw error;\n            }\n            console.log('Successfully created customer with ID:', data.id);\n            return data;\n        } catch (error) {\n            console.error('Error in createCustomer:', error);\n            throw error; // Re-throw to allow proper error handling in UI\n        }\n    },\n    // Update customer\n    updateCustomer: async (id, customer)=>{\n        try {\n            // Add updated timestamp\n            const updatedCustomer = {\n                ...customer,\n                updatedAt: new Date().toISOString()\n            };\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).update(updatedCustomer).eq('id', id).select().single();\n            if (error) {\n                console.error(\"Error updating customer \".concat(id, \":\"), error.message);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Error in updateCustomer \".concat(id, \":\"), error);\n            return null;\n        }\n    },\n    // Delete customer\n    deleteCustomer: async (id)=>{\n        try {\n            const { error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).delete().eq('id', id);\n            if (error) {\n                console.error(\"Error deleting customer \".concat(id, \":\"), error.message);\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in deleteCustomer \".concat(id, \":\"), error);\n            return false;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0NBQW9DO0FBRXVCO0FBRTNELHlCQUF5QjtBQUN6QixNQUFNQyxpQkFBaUI7QUFFdkIscUNBQXFDO0FBQ3JDLE1BQU1DLGlCQUE2QjtJQUNqQztRQUNFQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7UUFDakNFLFVBQVU7SUFDWjtJQUNBO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7UUFDakNDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztRQUNqQ0UsVUFBVTtJQUNaO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztRQUNqQ0MsV0FBVyxJQUFJRixPQUFPQyxXQUFXO1FBQ2pDRSxVQUFVO0lBQ1o7Q0FDRDtBQUVNLE1BQU1DLGNBQWM7SUFDekIsc0VBQXNFO0lBQ3RFQyxjQUFjO1FBQ1osSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWxCLHFEQUFRQSxDQUNuQ21CLElBQUksQ0FBQ2xCLGdCQUNMbUIsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQyxhQUFhO2dCQUFFQyxXQUFXO1lBQU07WUFFekMsSUFBSUosT0FBTztnQkFDVEgsUUFBUVEsSUFBSSxDQUFDLDJDQUEyQ0wsTUFBTU0sT0FBTztnQkFDckVULFFBQVFVLElBQUksQ0FBQztnQkFDYixPQUFPdkI7WUFDVDtZQUVBLHNEQUFz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d0I7WUFDeEIsTUFBTU8sa0JBQWtCO2dCQUN0QixHQUFHUCxRQUFRO2dCQUNYeEIsV0FBVyxJQUFJRixPQUFPQyxXQUFXO1lBQ25DO1lBRUEsTUFBTSxFQUFFTyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1sQixxREFBUUEsQ0FDbkNtQixJQUFJLENBQUNsQixnQkFDTDBDLE1BQU0sQ0FBQ0QsaUJBQ1BiLEVBQUUsQ0FBQyxNQUFNMUIsSUFDVGlCLE1BQU0sR0FDTlUsTUFBTTtZQUVULElBQUlaLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSGYsSUFBRyxNQUFJZSxNQUFNTSxPQUFPO2dCQUM3RCxNQUFNTjtZQUNSO1lBRUEsT0FBT0Q7UUFDVCxFQUFFLE9BQU9DLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIZixJQUFHLE1BQUllO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCMEIsZ0JBQWdCLE9BQU96QztRQUNyQixJQUFJO1lBQ0YsTUFBTSxFQUFFZSxLQUFLLEVBQUUsR0FBRyxNQUFNbEIscURBQVFBLENBQzdCbUIsSUFBSSxDQUFDbEIsZ0JBQ0w0QyxNQUFNLEdBQ05oQixFQUFFLENBQUMsTUFBTTFCO1lBRVosSUFBSWUsT0FBTztnQkFDVEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIZixJQUFHLE1BQUllLE1BQU1NLE9BQU87Z0JBQzdELE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVCxFQUFFLE9BQU9OLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIZixJQUFHLE1BQUllO1lBQ2hELE9BQU87UUFDVDtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuZmVuZy9wYXltZW50LWFnZW50LXBsYXRmb3JtL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSSBjbGllbnQgZm9yIGN1c3RvbWVyIGVuZHBvaW50c1xuaW1wb3J0IHsgQ3VzdG9tZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvY3VzdG9tZXIvY3VzdG9tZXInO1xuaW1wb3J0IHsgc3VwYWJhc2UsIHNhZmVRdWVyeSB9IGZyb20gJy4uLy4uL3V0aWxzL3N1cGFiYXNlJztcblxuLy8gVGFibGUgbmFtZSBpbiBTdXBhYmFzZVxuY29uc3QgQ1VTVE9NRVJfVEFCTEUgPSAnY3VzdG9tZXJzJztcblxuLy8gTW9jayBkYXRhIGZvciBkZXZlbG9wbWVudC9mYWxsYmFja1xuY29uc3QgTU9DS19DVVNUT01FUlM6IEN1c3RvbWVyW10gPSBbXG4gIHtcbiAgICBpZDogJzEnLFxuICAgIG5hbWU6ICdBY21lIENvcnBvcmF0aW9uJyxcbiAgICBlbWFpbDogJ2NvbnRhY3RAYWNtZS5jb20nLFxuICAgIHBob25lOiAnNTU1LTEyMy00NTY3JyxcbiAgICBhZGRyZXNzOiAnMTIzIEJ1c2luZXNzIEF2ZSwgU3VpdGUgMTAwLCBOZXcgWW9yaywgTlkgMTAwMDEnLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGlzQWN0aXZlOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBpZDogJzInLFxuICAgIG5hbWU6ICdHbG9iZXggSW5kdXN0cmllcycsXG4gICAgZW1haWw6ICdpbmZvQGdsb2JleC5jb20nLFxuICAgIHBob25lOiAnNTU1LTk4Ny02NTQzJyxcbiAgICBhZGRyZXNzOiAnNDU2IENvcnBvcmF0ZSBCbHZkLCBDaGljYWdvLCBJTCA2MDYwMScsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgaXNBY3RpdmU6IHRydWVcbiAgfSxcbiAge1xuICAgIGlkOiAnMycsXG4gICAgbmFtZTogJ0luaXRlY2ggTExDJyxcbiAgICBlbWFpbDogJ3N1cHBvcnRAaW5pdGVjaC5jb20nLFxuICAgIHBob25lOiAnNTU1LTQ1Ni03ODkwJyxcbiAgICBhZGRyZXNzOiAnNzg5IFRlY2ggUGFyaywgU2FuIEZyYW5jaXNjbywgQ0EgOTQxMDUnLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGlzQWN0aXZlOiB0cnVlXG4gIH1cbl07XG5cbmV4cG9ydCBjb25zdCBDdXN0b21lckFQSSA9IHtcbiAgLy8gR2V0IGFsbCBjdXN0b21lcnMgd2l0aCBmYWxsYmFjayB0byBtb2NrIGRhdGEgb25seSBpZiBkYXRhYmFzZSBmYWlsc1xuICBnZXRDdXN0b21lcnM6IGFzeW5jICgpOiBQcm9taXNlPEN1c3RvbWVyW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGN1c3RvbWVycyBmcm9tIGRhdGFiYXNlLi4uJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkQXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGZldGNoaW5nIGN1c3RvbWVycyBmcm9tIFN1cGFiYXNlOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmluZm8oJ1VzaW5nIG1vY2sgY3VzdG9tZXIgZGF0YSBhcyBmYWxsYmFjaycpO1xuICAgICAgICByZXR1cm4gTU9DS19DVVNUT01FUlM7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhY3R1YWwgZGF0YWJhc2UgcmVzdWx0cywgZXZlbiBpZiBlbXB0eSBhcnJheVxuICAgICAgLy8gVGhpcyBlbnN1cmVzIG5ldyBjdXN0b21lcnMgYWRkZWQgdGhyb3VnaCBhZG1pbiBwYW5lbCB3aWxsIGJlIHNob3duXG4gICAgICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGN1c3RvbWVycyBmcm9tIGRhdGFiYXNlYCk7XG4gICAgICByZXR1cm4gZGF0YSBhcyBDdXN0b21lcltdIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDdXN0b21lcnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE1PQ0tfQ1VTVE9NRVJTOyAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGEgaW4gY2FzZSBvZiBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgY3VzdG9tZXIgYnkgSUQgZnJvbSBkYXRhYmFzZSAoZmFsbGJhY2sgdG8gbW9jayBkYXRhIG9ubHkgaWYgZXJyb3IpXG4gIGdldEN1c3RvbWVyOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Q3VzdG9tZXIgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBjdXN0b21lciAke2lkfSBmcm9tIGRhdGFiYXNlLi4uYCk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgc3RyaW5nIElEIHRvIFVVSUQgZm9ybWF0IGZvciBkYXRhYmFzZSBpZiBuZWVkZWRcbiAgICAgIGxldCBxdWVyeUlkID0gaWQ7XG4gICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBtb2NrIGRhdGEgSURzICgnMScsICcyJywgJzMnKVxuICAgICAgICAvLyBiZWluZyB1c2VkIGJlZm9yZSBtaWdyYXRpb24gdG8gZGF0YWJhc2VcbiAgICAgICAgcXVlcnlJZCA9IGAwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMCR7aWR9YDtcbiAgICAgICAgY29uc29sZS5sb2coYENvbnZlcnRpbmcgc2ltcGxlIElEICR7aWR9IHRvIFVVSUQgZm9ybWF0OiAke3F1ZXJ5SWR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHF1ZXJ5SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZmV0Y2hpbmcgY3VzdG9tZXIgJHtpZH06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIGZpbmQgaW4gbW9jayBkYXRhIGlmIGRhdGFiYXNlIHF1ZXJ5IGZhaWxlZFxuICAgICAgICBjb25zdCBtb2NrQ3VzdG9tZXIgPSBNT0NLX0NVU1RPTUVSUy5maW5kKGMgPT4gYy5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAobW9ja0N1c3RvbWVyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGN1c3RvbWVyICR7aWR9IGluIG1vY2sgZGF0YWApO1xuICAgICAgICAgIHJldHVybiBtb2NrQ3VzdG9tZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGN1c3RvbWVyICR7aWR9IGZyb20gZGF0YWJhc2VgKTtcbiAgICAgIHJldHVybiBkYXRhIGFzIEN1c3RvbWVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBnZXRDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICAvLyBMYXN0IHJlc29ydCBmYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IG1vY2tDdXN0b21lciA9IE1PQ0tfQ1VTVE9NRVJTLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgICByZXR1cm4gbW9ja0N1c3RvbWVyIHx8IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8vIENyZWF0ZSBuZXcgY3VzdG9tZXJcbiAgY3JlYXRlQ3VzdG9tZXI6IGFzeW5jIChjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgdGltZXN0YW1wc1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgY29uc3QgbmV3Q3VzdG9tZXIgPSB7XG4gICAgICAgIC4uLmN1c3RvbWVyLFxuICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgdXBkYXRlZEF0OiBub3dcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBuZXcgY3VzdG9tZXIgaW4gZGF0YWJhc2U6JywgeyAuLi5uZXdDdXN0b21lciwgZW1haWw6IGN1c3RvbWVyLmVtYWlsIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLmluc2VydChbbmV3Q3VzdG9tZXJdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY3VzdG9tZXI6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnMjM1MDUnKSB7IC8vIFVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b21lciB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIGN1c3RvbWVyIHdpdGggSUQ6JywgZGF0YS5pZCk7XG4gICAgICByZXR1cm4gZGF0YSBhcyBDdXN0b21lcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlQ3VzdG9tZXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGFsbG93IHByb3BlciBlcnJvciBoYW5kbGluZyBpbiBVSVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgY3VzdG9tZXJcbiAgdXBkYXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nLCBjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgdXBkYXRlZCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IHVwZGF0ZWRDdXN0b21lciA9IHtcbiAgICAgICAgLi4uY3VzdG9tZXIsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVkQ3VzdG9tZXIpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHVwZGF0ZUN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvLyBEZWxldGUgY3VzdG9tZXJcbiAgZGVsZXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBkZWxldGVDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiQ1VTVE9NRVJfVEFCTEUiLCJNT0NLX0NVU1RPTUVSUyIsImlkIiwibmFtZSIsImVtYWlsIiwicGhvbmUiLCJhZGRyZXNzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiaXNBY3RpdmUiLCJDdXN0b21lckFQSSIsImdldEN1c3RvbWVycyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJ3YXJuIiwibWVzc2FnZSIsImluZm8iLCJsZW5ndGgiLCJnZXRDdXN0b21lciIsInF1ZXJ5SWQiLCJlcSIsInNpbmdsZSIsIm1vY2tDdXN0b21lciIsImZpbmQiLCJjIiwiY3JlYXRlQ3VzdG9tZXIiLCJjdXN0b21lciIsIm5vdyIsIm5ld0N1c3RvbWVyIiwiaW5zZXJ0IiwiY29kZSIsIkVycm9yIiwidXBkYXRlQ3VzdG9tZXIiLCJ1cGRhdGVkQ3VzdG9tZXIiLCJ1cGRhdGUiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/api/customer/customer-api.ts\n"));

/***/ })

});