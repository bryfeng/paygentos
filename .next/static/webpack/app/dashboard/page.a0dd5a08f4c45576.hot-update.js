"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/api/customer/customer-api.ts":
/*!******************************************!*\
  !*** ./src/api/customer/customer-api.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerAPI: () => (/* binding */ CustomerAPI)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n// API client for customer endpoints\n\n// Table name in Supabase\nconst CUSTOMER_TABLE = 'customers';\n// Mock data for development/fallback\nconst MOCK_CUSTOMERS = [\n    {\n        id: '1',\n        name: 'Acme Corporation',\n        email: 'contact@acme.com',\n        phone: '555-123-4567',\n        address: '123 Business Ave, Suite 100, New York, NY 10001',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '2',\n        name: 'Globex Industries',\n        email: 'info@globex.com',\n        phone: '555-987-6543',\n        address: '456 Corporate Blvd, Chicago, IL 60601',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    },\n    {\n        id: '3',\n        name: 'Initech LLC',\n        email: 'support@initech.com',\n        phone: '555-456-7890',\n        address: '789 Tech Park, San Francisco, CA 94105',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        isActive: true\n    }\n];\nconst CustomerAPI = {\n    // Get all customers with fallback to mock data only if database fails\n    getCustomers: async ()=>{\n        try {\n            console.log('Fetching customers from database...');\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').order('createdAt', {\n                ascending: false\n            });\n            if (error) {\n                console.warn('Error fetching customers from Supabase:', error.message);\n                console.info('Using mock customer data as fallback');\n                return MOCK_CUSTOMERS;\n            }\n            if (data && data.length > 0) {\n                console.log(\"Successfully retrieved \".concat(data.length, \" customers from database\"));\n                return data;\n            } else {\n                console.log('No customers found in database, using mock data');\n                return MOCK_CUSTOMERS;\n            }\n        } catch (error) {\n            console.error('Error in getCustomers:', error);\n            return MOCK_CUSTOMERS; // Fallback to mock data in case of error\n        }\n    },\n    // Get customer by ID from database (fallback to mock data only if error)\n    getCustomer: async (id)=>{\n        try {\n            console.log(\"Fetching customer \".concat(id, \" from database...\"));\n            // Convert string ID to UUID format for database if needed\n            let queryId = id;\n            if (id.length === 1) {\n                // This handles the case of mock data IDs ('1', '2', '3')\n                // being used before migration to database\n                queryId = \"00000000-0000-0000-0000-00000000000\".concat(id);\n                console.log(\"Converting simple ID \".concat(id, \" to UUID format: \").concat(queryId));\n            }\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).select('*').eq('id', queryId).single();\n            if (error) {\n                console.warn(\"Error fetching customer \".concat(id, \":\"), error.message);\n                // Only try to find in mock data if database query failed\n                const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n                if (mockCustomer) {\n                    console.log(\"Found customer \".concat(id, \" in mock data\"));\n                    return mockCustomer;\n                }\n                return null;\n            }\n            console.log(\"Successfully retrieved customer \".concat(id, \" from database\"));\n            return data;\n        } catch (error) {\n            console.error(\"Error in getCustomer \".concat(id, \":\"), error);\n            // Last resort fallback to mock data\n            const mockCustomer = MOCK_CUSTOMERS.find((c)=>c.id === id);\n            return mockCustomer || null;\n        }\n    },\n    // Create new customer\n    createCustomer: async (customer)=>{\n        try {\n            // Add timestamps\n            const now = new Date().toISOString();\n            const newCustomer = {\n                ...customer,\n                createdAt: now,\n                updatedAt: now\n            };\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).insert([\n                newCustomer\n            ]).select().single();\n            if (error) {\n                console.error('Error creating customer:', error.message);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error('Error in createCustomer:', error);\n            return null;\n        }\n    },\n    // Update customer\n    updateCustomer: async (id, customer)=>{\n        try {\n            // Add updated timestamp\n            const updatedCustomer = {\n                ...customer,\n                updatedAt: new Date().toISOString()\n            };\n            const { data, error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).update(updatedCustomer).eq('id', id).select().single();\n            if (error) {\n                console.error(\"Error updating customer \".concat(id, \":\"), error.message);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Error in updateCustomer \".concat(id, \":\"), error);\n            return null;\n        }\n    },\n    // Delete customer\n    deleteCustomer: async (id)=>{\n        try {\n            const { error } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(CUSTOMER_TABLE).delete().eq('id', id);\n            if (error) {\n                console.error(\"Error deleting customer \".concat(id, \":\"), error.message);\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Error in deleteCustomer \".concat(id, \":\"), error);\n            return false;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcGkvY3VzdG9tZXIvY3VzdG9tZXItYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0NBQW9DO0FBRXVCO0FBRTNELHlCQUF5QjtBQUN6QixNQUFNQyxpQkFBaUI7QUFFdkIscUNBQXFDO0FBQ3JDLE1BQU1DLGlCQUE2QjtJQUNqQztRQUNFQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7UUFDakNFLFVBQVU7SUFDWjtJQUNBO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7UUFDakNDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztRQUNqQ0UsVUFBVTtJQUNaO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztRQUNqQ0MsV0FBVyxJQUFJRixPQUFPQyxXQUFXO1FBQ2pDRSxVQUFVO0lBQ1o7Q0FDRDtBQUVNLE1BQU1DLGNBQWM7SUFDekIsc0VBQXNFO0lBQ3RFQyxjQUFjO1FBQ1osSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWxCLHFEQUFRQSxDQUNuQ21CLElBQUksQ0FBQ2xCLGdCQUNMbUIsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQyxhQUFhO2dCQUFFQyxXQUFXO1lBQU07WUFFekMsSUFBSUosT0FBTztnQkFDVEgsUUFBUVEsSUFBSSxDQUFDLDJDQUEyQ0wsTUFBTU0sT0FBTztnQkFDckVULFFBQVFVLElBQUksQ0FBQztnQkFDYixPQUFPdkI7WUFDVDtZQUVBLElBQUll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QkFDUFgsRUFBRSxDQUFDLE1BQU0xQixJQUNUaUIsTUFBTSxHQUNOVSxNQUFNO1lBRVQsSUFBSVosT0FBTztnQkFDVEgsUUFBUUcsS0FBSyxDQUFDLDJCQUE4QixPQUFIZixJQUFHLE1BQUllLE1BQU1NLE9BQU87Z0JBQzdELE1BQU1OO1lBQ1I7WUFFQSxPQUFPRDtRQUNULEVBQUUsT0FBT0MsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsMkJBQThCLE9BQUhmLElBQUcsTUFBSWU7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEJ3QixnQkFBZ0IsT0FBT3ZDO1FBQ3JCLElBQUk7WUFDRixNQUFNLEVBQUVlLEtBQUssRUFBRSxHQUFHLE1BQU1sQixxREFBUUEsQ0FDN0JtQixJQUFJLENBQUNsQixnQkFDTDBDLE1BQU0sR0FDTmQsRUFBRSxDQUFDLE1BQU0xQjtZQUVaLElBQUllLE9BQU87Z0JBQ1RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSGYsSUFBRyxNQUFJZSxNQUFNTSxPQUFPO2dCQUM3RCxPQUFPO1lBQ1Q7WUFFQSxPQUFPO1FBQ1QsRUFBRSxPQUFPTixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQywyQkFBOEIsT0FBSGYsSUFBRyxNQUFJZTtZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbmZlbmcvcGF5bWVudC1hZ2VudC1wbGF0Zm9ybS9zcmMvYXBpL2N1c3RvbWVyL2N1c3RvbWVyLWFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgY2xpZW50IGZvciBjdXN0b21lciBlbmRwb2ludHNcbmltcG9ydCB7IEN1c3RvbWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2N1c3RvbWVyL2N1c3RvbWVyJztcbmltcG9ydCB7IHN1cGFiYXNlLCBzYWZlUXVlcnkgfSBmcm9tICcuLi8uLi91dGlscy9zdXBhYmFzZSc7XG5cbi8vIFRhYmxlIG5hbWUgaW4gU3VwYWJhc2VcbmNvbnN0IENVU1RPTUVSX1RBQkxFID0gJ2N1c3RvbWVycyc7XG5cbi8vIE1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnQvZmFsbGJhY2tcbmNvbnN0IE1PQ0tfQ1VTVE9NRVJTOiBDdXN0b21lcltdID0gW1xuICB7XG4gICAgaWQ6ICcxJyxcbiAgICBuYW1lOiAnQWNtZSBDb3Jwb3JhdGlvbicsXG4gICAgZW1haWw6ICdjb250YWN0QGFjbWUuY29tJyxcbiAgICBwaG9uZTogJzU1NS0xMjMtNDU2NycsXG4gICAgYWRkcmVzczogJzEyMyBCdXNpbmVzcyBBdmUsIFN1aXRlIDEwMCwgTmV3IFlvcmssIE5ZIDEwMDAxJyxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBpc0FjdGl2ZTogdHJ1ZVxuICB9LFxuICB7XG4gICAgaWQ6ICcyJyxcbiAgICBuYW1lOiAnR2xvYmV4IEluZHVzdHJpZXMnLFxuICAgIGVtYWlsOiAnaW5mb0BnbG9iZXguY29tJyxcbiAgICBwaG9uZTogJzU1NS05ODctNjU0MycsXG4gICAgYWRkcmVzczogJzQ1NiBDb3Jwb3JhdGUgQmx2ZCwgQ2hpY2FnbywgSUwgNjA2MDEnLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGlzQWN0aXZlOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBpZDogJzMnLFxuICAgIG5hbWU6ICdJbml0ZWNoIExMQycsXG4gICAgZW1haWw6ICdzdXBwb3J0QGluaXRlY2guY29tJyxcbiAgICBwaG9uZTogJzU1NS00NTYtNzg5MCcsXG4gICAgYWRkcmVzczogJzc4OSBUZWNoIFBhcmssIFNhbiBGcmFuY2lzY28sIENBIDk0MTA1JyxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBpc0FjdGl2ZTogdHJ1ZVxuICB9XG5dO1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tZXJBUEkgPSB7XG4gIC8vIEdldCBhbGwgY3VzdG9tZXJzIHdpdGggZmFsbGJhY2sgdG8gbW9jayBkYXRhIG9ubHkgaWYgZGF0YWJhc2UgZmFpbHNcbiAgZ2V0Q3VzdG9tZXJzOiBhc3luYyAoKTogUHJvbWlzZTxDdXN0b21lcltdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBjdXN0b21lcnMgZnJvbSBkYXRhYmFzZS4uLicpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZEF0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBmZXRjaGluZyBjdXN0b21lcnMgZnJvbSBTdXBhYmFzZTonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCdVc2luZyBtb2NrIGN1c3RvbWVyIGRhdGEgYXMgZmFsbGJhY2snKTtcbiAgICAgICAgcmV0dXJuIE1PQ0tfQ1VTVE9NRVJTO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgJHtkYXRhLmxlbmd0aH0gY3VzdG9tZXJzIGZyb20gZGF0YWJhc2VgKTtcbiAgICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXJbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBjdXN0b21lcnMgZm91bmQgaW4gZGF0YWJhc2UsIHVzaW5nIG1vY2sgZGF0YScpO1xuICAgICAgICByZXR1cm4gTU9DS19DVVNUT01FUlM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldEN1c3RvbWVyczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gTU9DS19DVVNUT01FUlM7IC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YSBpbiBjYXNlIG9mIGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBjdXN0b21lciBieSBJRCBmcm9tIGRhdGFiYXNlIChmYWxsYmFjayB0byBtb2NrIGRhdGEgb25seSBpZiBlcnJvcilcbiAgZ2V0Q3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxDdXN0b21lciB8IG51bGw+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGN1c3RvbWVyICR7aWR9IGZyb20gZGF0YWJhc2UuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBzdHJpbmcgSUQgdG8gVVVJRCBmb3JtYXQgZm9yIGRhdGFiYXNlIGlmIG5lZWRlZFxuICAgICAgbGV0IHF1ZXJ5SWQgPSBpZDtcbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIG1vY2sgZGF0YSBJRHMgKCcxJywgJzInLCAnMycpXG4gICAgICAgIC8vIGJlaW5nIHVzZWQgYmVmb3JlIG1pZ3JhdGlvbiB0byBkYXRhYmFzZVxuICAgICAgICBxdWVyeUlkID0gYDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwJHtpZH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVydGluZyBzaW1wbGUgSUQgJHtpZH0gdG8gVVVJRCBmb3JtYXQ6ICR7cXVlcnlJZH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oQ1VTVE9NRVJfVEFCTEUpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcXVlcnlJZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBmZXRjaGluZyBjdXN0b21lciAke2lkfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgLy8gT25seSB0cnkgdG8gZmluZCBpbiBtb2NrIGRhdGEgaWYgZGF0YWJhc2UgcXVlcnkgZmFpbGVkXG4gICAgICAgIGNvbnN0IG1vY2tDdXN0b21lciA9IE1PQ0tfQ1VTVE9NRVJTLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChtb2NrQ3VzdG9tZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgY3VzdG9tZXIgJHtpZH0gaW4gbW9jayBkYXRhYCk7XG4gICAgICAgICAgcmV0dXJuIG1vY2tDdXN0b21lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgY3VzdG9tZXIgJHtpZH0gZnJvbSBkYXRhYmFzZWApO1xuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldEN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIC8vIExhc3QgcmVzb3J0IGZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgY29uc3QgbW9ja0N1c3RvbWVyID0gTU9DS19DVVNUT01FUlMuZmluZChjID0+IGMuaWQgPT09IGlkKTtcbiAgICAgIHJldHVybiBtb2NrQ3VzdG9tZXIgfHwgbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBjcmVhdGVDdXN0b21lcjogYXN5bmMgKGN1c3RvbWVyOiBQYXJ0aWFsPEN1c3RvbWVyPik6IFByb21pc2U8Q3VzdG9tZXIgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCB0aW1lc3RhbXBzXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICBjb25zdCBuZXdDdXN0b21lciA9IHtcbiAgICAgICAgLi4uY3VzdG9tZXIsXG4gICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICB1cGRhdGVkQXQ6IG5vd1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oQ1VTVE9NRVJfVEFCTEUpXG4gICAgICAgIC5pbnNlcnQoW25ld0N1c3RvbWVyXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGN1c3RvbWVyOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZUN1c3RvbWVyOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgY3VzdG9tZXJcbiAgdXBkYXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nLCBjdXN0b21lcjogUGFydGlhbDxDdXN0b21lcj4pOiBQcm9taXNlPEN1c3RvbWVyIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgdXBkYXRlZCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IHVwZGF0ZWRDdXN0b21lciA9IHtcbiAgICAgICAgLi4uY3VzdG9tZXIsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShDVVNUT01FUl9UQUJMRSlcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVkQ3VzdG9tZXIpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgYXMgQ3VzdG9tZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHVwZGF0ZUN1c3RvbWVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvLyBEZWxldGUgY3VzdG9tZXJcbiAgZGVsZXRlQ3VzdG9tZXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKENVU1RPTUVSX1RBQkxFKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGN1c3RvbWVyICR7aWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBkZWxldGVDdXN0b21lciAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiQ1VTVE9NRVJfVEFCTEUiLCJNT0NLX0NVU1RPTUVSUyIsImlkIiwibmFtZSIsImVtYWlsIiwicGhvbmUiLCJhZGRyZXNzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiaXNBY3RpdmUiLCJDdXN0b21lckFQSSIsImdldEN1c3RvbWVycyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJ3YXJuIiwibWVzc2FnZSIsImluZm8iLCJsZW5ndGgiLCJnZXRDdXN0b21lciIsInF1ZXJ5SWQiLCJlcSIsInNpbmdsZSIsIm1vY2tDdXN0b21lciIsImZpbmQiLCJjIiwiY3JlYXRlQ3VzdG9tZXIiLCJjdXN0b21lciIsIm5vdyIsIm5ld0N1c3RvbWVyIiwiaW5zZXJ0IiwidXBkYXRlQ3VzdG9tZXIiLCJ1cGRhdGVkQ3VzdG9tZXIiLCJ1cGRhdGUiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/api/customer/customer-api.ts\n"));

/***/ })

});